// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target x86_64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftUI_UDF_Binary
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CoreLocation/*.CLAuthorizationStatus*/
import CoreLocation/*.CLLocation*/
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
public struct AnyAction {
  public let value: SwiftUI_UDF_Binary.Actionable
  public init<T>(_ value: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
}
extension SwiftUI_UDF_Binary.AnyAction : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.AnyAction, rhs: SwiftUI_UDF_Binary.AnyAction) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.AnyAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol WrappedReducer : SwiftUI_UDF_Binary.Reducing {
  var reducer: SwiftUI_UDF_Binary.Reducing { get set }
}
extension SwiftUI_UDF_Binary.WrappedReducer {
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
public protocol IdentifiableFlow : SwiftUI_UDF_Binary.Flow {
  associatedtype FlowId
  static var id: Self.FlowId { get }
}
extension SwiftUI_UDF_Binary.IdentifiableFlow where Self.FlowId == SwiftUI_UDF_Binary.Flows.Id {
  public static var id: SwiftUI_UDF_Binary.Flows.Id {
    get
  }
}
public protocol NavigationContainerLinking : SwiftUI.View {
  var isDetailLink: Swift.Bool { get set }
  func isDetailLink(_ isDetailLink: Swift.Bool) -> Self
}
extension SwiftUI_UDF_Binary.NavigationContainerLinking {
  public func isDetailLink(_ isDetailLink: Swift.Bool) -> Self
}
public protocol Component : SwiftUI.View {
  associatedtype Props
  var props: Self.Props { get }
  init(props: Self.Props)
}
public protocol PureEffect : Combine.Publisher {
  var upstream: Combine.AnyPublisher<Self.Output, Self.Failure> { get }
}
extension SwiftUI_UDF_Binary.PureEffect {
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.AnyAction, failure: @escaping (Self.Failure) -> SwiftUI_UDF_Binary.AnyAction) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
}
extension SwiftUI_UDF_Binary.PureEffect where Self.Failure == Swift.Never {
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.AnyAction) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
  public func eraseToEffectable<O>(output: @escaping (Self.Output) -> O) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> where O : Swift.Equatable, O : SwiftUI_UDF_Binary.Actionable
}
extension Combine.AnyPublisher : SwiftUI_UDF_Binary.PureEffect where Output == SwiftUI_UDF_Binary.AnyAction, Failure == Swift.Never {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> {
    get
  }
}
public protocol ErasableToEffect {
  var asEffectable: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> { get }
}
public protocol ActionLogging {
  func log(_ action: SwiftUI_UDF_Binary.AnyAction)
}
@propertyWrapper final public class Cached<T> : SwiftUI_UDF_Binary.Initable where T : Swift.Decodable, T : Swift.Encodable {
  final public var key: Swift.String
  final public var defaultValue: T
  final public var intervalToSync: Foundation.TimeInterval
  public init()
  public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 1, storage: SwiftUI_UDF_Binary.CacheSource)
  convenience public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 1)
  public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 1, storage: SwiftUI_UDF_Binary.CacheSource) where T : SwiftUI_UDF_Binary.Initable
  convenience public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 1) where T : SwiftUI_UDF_Binary.Initable
  final public var wrappedValue: T {
    get
    set
  }
  final public func reset()
  @objc deinit
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.IsEquatable where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.Reducing where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.WrappedReducer where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
  final public var reducer: SwiftUI_UDF_Binary.Reducing {
    get
    set
  }
}
extension SwiftUI_UDF_Binary.Cached : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.Cached<T>, rhs: SwiftUI_UDF_Binary.Cached<T>) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.Cached : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct EmptyReducer : SwiftUI_UDF_Binary.AppReducer, Swift.Equatable {
  public init()
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction) -> Swift.Bool
  public static func == (a: SwiftUI_UDF_Binary.EmptyReducer, b: SwiftUI_UDF_Binary.EmptyReducer) -> Swift.Bool
}
public protocol Mergeable {
  func merging(_ newValue: Self) -> Self
  func filled(from value: Self, mutate: (_ filled: inout Self, _ old: Self) -> Swift.Void) -> Self
}
extension Swift.Dictionary where Value : SwiftUI_UDF_Binary.Mergeable {
  public subscript(key: Key) -> Value {
    get
    set
  }
}
extension Swift.Dictionary where Key == Value.ID, Value : Swift.Identifiable {
  public mutating func insert(items: [Value])
  public mutating func insert(item: Value)
}
public typealias MI = Swift.Identifiable & SwiftUI_UDF_Binary.Mergeable
extension Swift.Dictionary where Key == Value.ID, Value : Swift.Identifiable, Value : SwiftUI_UDF_Binary.Mergeable {
  public mutating func insert(items: [Value])
  public mutating func insert(item: Value)
}
@propertyWrapper public struct FormField<F, Value> : SwiftUI_UDF_Binary.Reducible where F : Swift.Equatable, F : SwiftUI_UDF_Binary.Formable, Value : Swift.Equatable {
  public init()
  public var wrappedValue: Value
  public init(wrappedValue value: Value, _ formType: F.Type)
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  public static func == (a: SwiftUI_UDF_Binary.FormField<F, Value>, b: SwiftUI_UDF_Binary.FormField<F, Value>) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.FormField : Swift.Codable where Value : Swift.Decodable, Value : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol AppReducer {
  mutating func preReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  mutating func postReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
extension SwiftUI_UDF_Binary.AppReducer {
  public func preReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  public func postReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
public protocol IsEquatable {
  func isEqual(_ rhs: SwiftUI_UDF_Binary.IsEquatable) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.IsEquatable where Self : Swift.Equatable {
  public func isEqual(_ rhs: SwiftUI_UDF_Binary.IsEquatable) -> Swift.Bool
}
public protocol Actionable {
}
extension SwiftUI_UDF_Binary.Actionable where Self : Swift.Equatable {
  public func eraseToAnyAction(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.AnyAction
}
public protocol ProtectedAction : Swift.Equatable, SwiftUI_UDF_Binary.Actionable {
}
extension SwiftUI_UDF_Binary.Effects {
  public struct Delay : SwiftUI_UDF_Binary.Effectable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
    public init<E>(_ effect: E, _ duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.AnyAction
  }
}
public protocol Scope : SwiftUI_UDF_Binary.IsEquatable {
}
public typealias EquatableScope = Swift.Equatable & SwiftUI_UDF_Binary.Scope
public enum Scopes {
  public static func Combined<S1, S2>(_ s1: S1, _ s2: S2) -> SwiftUI_UDF_Binary.CombinedScope<S1, S2> where S1 : Swift.Equatable, S1 : SwiftUI_UDF_Binary.Scope, S2 : Swift.Equatable, S2 : SwiftUI_UDF_Binary.Scope
  public static func Combined<S1, S2, S3>(_ s1: S1, _ s2: S2, _ s3: S3) -> SwiftUI_UDF_Binary.CombinedScope<S1, SwiftUI_UDF_Binary.CombinedScope<S2, S3>> where S1 : Swift.Equatable, S1 : SwiftUI_UDF_Binary.Scope, S2 : Swift.Equatable, S2 : SwiftUI_UDF_Binary.Scope, S3 : Swift.Equatable, S3 : SwiftUI_UDF_Binary.Scope
  public static func Combined<S1, S2, S3, S4>(_ s1: S1, _ s2: S2, _ s3: S3, _ s4: S4) -> SwiftUI_UDF_Binary.CombinedScope<SwiftUI_UDF_Binary.CombinedScope<S1, S2>, SwiftUI_UDF_Binary.CombinedScope<S3, S4>> where S1 : Swift.Equatable, S1 : SwiftUI_UDF_Binary.Scope, S2 : Swift.Equatable, S2 : SwiftUI_UDF_Binary.Scope, S3 : Swift.Equatable, S3 : SwiftUI_UDF_Binary.Scope, S4 : Swift.Equatable, S4 : SwiftUI_UDF_Binary.Scope
}
public struct RenderContainer<V, AppState> : SwiftUI_UDF_Binary.Container where V : SwiftUI.View, AppState : Swift.Equatable, AppState : SwiftUI_UDF_Binary.AppReducer {
  public typealias ContainerComponent = SwiftUI_UDF_Binary.RenderComponent<V>
  public var viewToRender: V
  public init(viewToRender: V) where AppState == SwiftUI_UDF_Binary.EmptyReducer
  public init(_ state: AppState, viewToRender: V)
  public init(_ state: AppState, @SwiftUI.ViewBuilder viewToRender: () -> V)
  public func map(state: AppState, store: SwiftUI_UDF_Binary.EnvironmentStore<AppState>) -> SwiftUI_UDF_Binary.RenderContainer<V, AppState>.ContainerComponent.Props
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderContainerV4bodyQrvp", 0) __<V, AppState>
  public typealias ContainerState = AppState
}
public struct RenderComponent<V> : SwiftUI_UDF_Binary.Component where V : SwiftUI.View {
  public struct Props {
  }
  public var props: SwiftUI_UDF_Binary.RenderComponent<V>.Props
  public init(props: SwiftUI_UDF_Binary.RenderComponent<V>.Props)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderComponentV4bodyQrvp", 0) __<V>
}
@_Concurrency.MainActor(unsafe) public struct TagNavigationLink<State, Label, Destination, Tag> : SwiftUI_UDF_Binary.NavigationContainerLinking where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Label : SwiftUI.View, Destination : SwiftUI.View, Tag : Swift.Hashable {
  @_Concurrency.MainActor(unsafe) public var isDetailLink: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary17TagNavigationLinkV4bodyQrvp", 0) __<State, Label, Destination, Tag>
}
extension SwiftUI_UDF_Binary.Mergeable {
  public func filled(from value: Self, mutate: (_ filledValue: inout Self, _ oldValue: Self) -> Swift.Void) -> Self
}
public protocol Formable : SwiftUI_UDF_Binary.Reducing {
}
public typealias Form = SwiftUI_UDF_Binary.Formable & SwiftUI_UDF_Binary.Reducible
@_Concurrency.MainActor(unsafe) public struct IsActiveNavigationLink<State, Label, Destination> : SwiftUI_UDF_Binary.NavigationContainerLinking where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Label : SwiftUI.View, Destination : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var isDetailLink: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary22IsActiveNavigationLinkV4bodyQrvp", 0) __<State, Label, Destination>
}
public enum Actions {
  public struct Error : SwiftUI_UDF_Binary.EquatableAction {
    public var error: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(error: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Error, b: SwiftUI_UDF_Binary.Actions.Error) -> Swift.Bool
  }
  public struct Message : SwiftUI_UDF_Binary.EquatableAction {
    public var message: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(message: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Message, b: SwiftUI_UDF_Binary.Actions.Message) -> Swift.Bool
  }
  public struct LoadPage : SwiftUI_UDF_Binary.EquatableAction {
    public var id: Swift.AnyHashable
    public var pageNumber: Swift.Int
    public init<Id>(pageNumber: Swift.Int = 1, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.LoadPage, b: SwiftUI_UDF_Binary.Actions.LoadPage) -> Swift.Bool
  }
  public struct SetPaginationItems<I> : SwiftUI_UDF_Binary.EquatableAction where I : Swift.Equatable {
    public var id: Swift.AnyHashable
    public var items: [I]
    public init<Id>(items: [I], id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>, b: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>) -> Swift.Bool
  }
  public struct DidCancelEffect : SwiftUI_UDF_Binary.EquatableAction {
    public var cancelation: Swift.AnyHashable
    public init<Id>(by cancelation: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidCancelEffect, b: SwiftUI_UDF_Binary.Actions.DidCancelEffect) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct UpdateFormField<F, V> : SwiftUI_UDF_Binary.EquatableAction where F : SwiftUI_UDF_Binary.Formable, V : Swift.Equatable {
    public var keyPath: Swift.WritableKeyPath<F, V>
    public var value: V
    public init(keyPath: Swift.WritableKeyPath<F, V>, value: V)
    public static func == (a: SwiftUI_UDF_Binary.Actions.UpdateFormField<F, V>, b: SwiftUI_UDF_Binary.Actions.UpdateFormField<F, V>) -> Swift.Bool
  }
  public struct ResetForm<F> : SwiftUI_UDF_Binary.EquatableAction where F : SwiftUI_UDF_Binary.Formable {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.ResetForm<F>, b: SwiftUI_UDF_Binary.Actions.ResetForm<F>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct DidLoadItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>) -> Swift.Bool
  }
  public struct DidLoadItems<M> : SwiftUI_UDF_Binary.EquatableAction, Swift.CustomStringConvertible where M : Swift.Equatable {
    public var items: [M]
    public var id: Swift.AnyHashable
    public var shortDescription: Swift.Bool
    public init<Id>(items: [M], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>) -> Swift.Bool
  }
  public struct DidUpdateItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>, b: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>) -> Swift.Bool
  }
  public struct DeleteItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteItem<M>, b: SwiftUI_UDF_Binary.Actions.DeleteItem<M>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct DidLoadNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedItems<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var items: [Nested]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public var parentId: ParentId
    public init(parentId: ParentId, items: [Nested], shortDescription: Swift.Bool = true)
    public init<Id>(parentId: ParentId, items: [Nested], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedByParents<ParentId, Nested> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var dictionary: [ParentId : [Nested]]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public init(dictionary: [ParentId : [Nested]], shortDescription: Swift.Bool = true)
    public init<Id>(dictionary: [ParentId : [Nested]], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidUpdateNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DeleteNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct RequestLocationAccess : SwiftUI_UDF_Binary.EquatableAction {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.RequestLocationAccess, b: SwiftUI_UDF_Binary.Actions.RequestLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateLocationAccess : SwiftUI_UDF_Binary.EquatableAction {
    public var access: CoreLocation.CLAuthorizationStatus
    public init(access: CoreLocation.CLAuthorizationStatus)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess, b: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateUserLocation : SwiftUI_UDF_Binary.EquatableAction {
    public var location: CoreLocation.CLLocation
    public init(location: CoreLocation.CLLocation)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation, b: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation) -> Swift.Bool
  }
}
@_hasMissingDesignatedInitializers final public class CombinedScope<S1, S2> : SwiftUI_UDF_Binary.EquatableScope where S1 : Swift.Equatable, S1 : SwiftUI_UDF_Binary.Scope, S2 : Swift.Equatable, S2 : SwiftUI_UDF_Binary.Scope {
  public static func == (lhs: SwiftUI_UDF_Binary.CombinedScope<S1, S2>, rhs: SwiftUI_UDF_Binary.CombinedScope<S1, S2>) -> Swift.Bool
  @objc deinit
}
public protocol Routing : SwiftUI_UDF_Binary.Initable {
  associatedtype Route
  associatedtype View : SwiftUI.View
  @SwiftUI.ViewBuilder func view(for route: Self.Route) -> Self.View
}
open class Router<R> where R : SwiftUI_UDF_Binary.Routing {
  public var routing: R
  public init(routing: R)
  public init()
  open func view(for route: R.Route) -> some SwiftUI.View
  
  @objc deinit
}
public protocol Initable {
  init()
}
extension Swift.Dictionary : SwiftUI_UDF_Binary.Initable {
}
extension Swift.Set : SwiftUI_UDF_Binary.Initable {
}
extension Swift.Array : SwiftUI_UDF_Binary.Initable {
}
public typealias EquatableAction = Swift.Equatable & SwiftUI_UDF_Binary.Actionable
public typealias Command = () -> ()
public typealias CommandWith<T> = (T) -> ()
public protocol CacheSource {
  init(key: Swift.String)
  func save<T>(_ value: T) where T : Swift.Encodable
  func load<T>() -> T? where T : Swift.Decodable
  func remove()
}
public enum Effects {
}
public protocol Effectable : SwiftUI_UDF_Binary.PureEffect where Self.Failure == Swift.Never, Self.Output == SwiftUI_UDF_Binary.AnyAction {
}
extension SwiftUI_UDF_Binary.Effectable {
  public func filterAction<A>(_ isIncluded: @escaping (A) -> Swift.Bool) -> some SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Actionable
  
  public func delay(duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) -> some SwiftUI_UDF_Binary.Effectable
  
}
@_Concurrency.MainActor(unsafe) public struct ItemNavigationLink<State, I, Label, Destination> : SwiftUI_UDF_Binary.NavigationContainerLinking where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Label : SwiftUI.View, Destination : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var item: SwiftUI.Binding<I?>
  @_Concurrency.MainActor(unsafe) public var destination: (I) -> Destination
  @_Concurrency.MainActor(unsafe) public var label: () -> Label
  @_Concurrency.MainActor(unsafe) public var isDetailLink: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary18ItemNavigationLinkV4bodyQrvp", 0) __<State, I, Label, Destination>
}
extension CoreLocation.CLAuthorizationStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Container : SwiftUI.View {
  associatedtype ContainerState : Swift.Equatable, SwiftUI_UDF_Binary.AppReducer
  associatedtype ContainerComponent : SwiftUI_UDF_Binary.Component
  func map(state: Self.ContainerState, store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>) -> Self.ContainerComponent.Props
  func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
extension SwiftUI_UDF_Binary.Container {
  public func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
extension SwiftUI_UDF_Binary.Container {
  public var body: some SwiftUI.View {
    get
  }
}
@_functionBuilder public enum ActionGroupBuilder {
  public static func buildArray(_ components: [[SwiftUI_UDF_Binary.AnyAction]]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildBlock(_ components: [SwiftUI_UDF_Binary.AnyAction]...) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildExpression<T>(_ expression: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> [SwiftUI_UDF_Binary.AnyAction] where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public static func buildExpression(_ expression: SwiftUI_UDF_Binary.AnyAction) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildExpression(_ expression: Swift.Void) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildOptional(_ component: [SwiftUI_UDF_Binary.AnyAction]?) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildEither(first component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildEither(second component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildLimitedAvailability(_ component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildFinalResult(_ component: [SwiftUI_UDF_Binary.AnyAction]) -> SwiftUI_UDF_Binary.ActionGroup
}
open class Middleware<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public var store: SwiftUI_UDF_Binary.Store<State>
  public var queue: Dispatch.DispatchQueue
  public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  required convenience public init(store: SwiftUI_UDF_Binary.Store<State>)
  open func status(for state: State) -> SwiftUI_UDF_Binary.Middleware<State>.Status
  public typealias DispatchFilter<Output> = (_ state: State, _ output: Output) -> Swift.Bool
  public var cancelations: [Swift.AnyHashable : Combine.AnyCancellable]
  public func execute<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func execute<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable
  public func run<E, Id, F>(_ effect: E, cancelation: Id, dispatchFilter: @escaping SwiftUI_UDF_Binary.Middleware<State>.DispatchFilter<F>) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, F : Swift.Equatable, F : SwiftUI_UDF_Binary.Actionable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func run<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  @discardableResult
  public func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  public func cancelAll()
  public func execute<E>(_ effect: E) where E : SwiftUI_UDF_Binary.PureEffect, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func execute<E>(_ effect: E) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect
  @objc deinit
}
extension SwiftUI_UDF_Binary.Middleware : Swift.Hashable {
  public static func == (lhs: SwiftUI_UDF_Binary.Middleware<State>, rhs: SwiftUI_UDF_Binary.Middleware<State>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  open var hashValue: Swift.Int {
    get
  }
}
extension SwiftUI_UDF_Binary.Middleware {
  public enum Status {
    case active
    case suspended
    public static func == (a: SwiftUI_UDF_Binary.Middleware<State>.Status, b: SwiftUI_UDF_Binary.Middleware<State>.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@_Concurrency.MainActor(unsafe) public struct NavigationContainerLink<NavLink, State, Label, Destination> : SwiftUI.View where NavLink : SwiftUI_UDF_Binary.NavigationContainerLinking, State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Label : SwiftUI.View, Destination : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  @_Concurrency.MainActor(unsafe) public func isDetailLink(_ isDetailLink: Swift.Bool) -> SwiftUI_UDF_Binary.NavigationContainerLink<NavLink, State, Label, Destination>
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary23NavigationContainerLinkV4bodyQrvp", 0) __<NavLink, State, Label, Destination>
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.PlainNavigationLink<State, Label, Destination> {
  @_Concurrency.MainActor(unsafe) public init(_ stateType: State.Type, @SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label)
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.PlainNavigationLink<State, Label, Destination>, State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init(@SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label)
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, Label, Destination> {
  @_Concurrency.MainActor(unsafe) public init(_ stateType: State.Type, isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  @_Concurrency.MainActor(unsafe) public init(_ stateType: State.Type, isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, SwiftUI.EmptyView, Destination>, Label == SwiftUI.EmptyView
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, Label, Destination>, State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init(isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  @_Concurrency.MainActor(unsafe) public init(isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, SwiftUI.EmptyView, Destination>, Label == SwiftUI.EmptyView
}
extension SwiftUI_UDF_Binary.NavigationContainerLink {
  @_Concurrency.MainActor(unsafe) public init<V>(_ stateType: State.Type, tag: V, selection: SwiftUI.Binding<V?>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label) where NavLink == SwiftUI_UDF_Binary.TagNavigationLink<State, Label, Destination, V>, V : Swift.Hashable
  @_Concurrency.MainActor(unsafe) public init<V>(_ stateType: State.Type, tag: V, selection: SwiftUI.Binding<V?>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) where NavLink == SwiftUI_UDF_Binary.TagNavigationLink<State, SwiftUI.EmptyView, Destination, V>, Label == SwiftUI.EmptyView, V : Swift.Hashable
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init<V>(tag: V, selection: SwiftUI.Binding<V?>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label) where NavLink == SwiftUI_UDF_Binary.TagNavigationLink<State, Label, Destination, V>, V : Swift.Hashable
  @_Concurrency.MainActor(unsafe) public init<V>(tag: V, selection: SwiftUI.Binding<V?>, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) where NavLink == SwiftUI_UDF_Binary.TagNavigationLink<State, SwiftUI.EmptyView, Destination, V>, Label == SwiftUI.EmptyView, V : Swift.Hashable
}
extension SwiftUI_UDF_Binary.NavigationContainerLink where State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init<I>(item: SwiftUI.Binding<I?>, @SwiftUI.ViewBuilder destination: @escaping (I) -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label) where NavLink == SwiftUI_UDF_Binary.ItemNavigationLink<State, I, Label, Destination>
  @_Concurrency.MainActor(unsafe) public init<I>(item: SwiftUI.Binding<I?>, @SwiftUI.ViewBuilder destination: @escaping (I) -> Destination) where NavLink == SwiftUI_UDF_Binary.ItemNavigationLink<State, I, SwiftUI.EmptyView, Destination>, Label == SwiftUI.EmptyView
}
extension SwiftUI_UDF_Binary.NavigationContainerLink {
  @_Concurrency.MainActor(unsafe) public init<I>(_ stateType: State.Type, item: SwiftUI.Binding<I?>, @SwiftUI.ViewBuilder destination: @escaping (I) -> Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label) where NavLink == SwiftUI_UDF_Binary.ItemNavigationLink<State, I, Label, Destination>
  @_Concurrency.MainActor(unsafe) public init<I>(_ stateType: State.Type, item: SwiftUI.Binding<I?>, @SwiftUI.ViewBuilder destination: @escaping (I) -> Destination) where NavLink == SwiftUI_UDF_Binary.ItemNavigationLink<State, I, SwiftUI.EmptyView, Destination>, Label == SwiftUI.EmptyView
}
@available(*, deprecated, message: "Use `NavigationContainerLink with destination as a closure`")
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.PlainNavigationLink<State, Label, Destination>, State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init(destination: Destination, @SwiftUI.ViewBuilder label: @escaping () -> Label)
}
@available(*, deprecated, message: "Use `NavigationContainerLink with destination as a closure`")
extension SwiftUI_UDF_Binary.NavigationContainerLink where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, Label, Destination>, State == Destination.ContainerState, Destination : SwiftUI_UDF_Binary.Container {
  @_Concurrency.MainActor(unsafe) public init(destination: Destination, isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  @_Concurrency.MainActor(unsafe) public init(destination: Destination, isActive: SwiftUI.Binding<Swift.Bool>) where NavLink == SwiftUI_UDF_Binary.IsActiveNavigationLink<State, SwiftUI.EmptyView, Destination>, Label == SwiftUI.EmptyView
}
public protocol Flow : Swift.Equatable, SwiftUI_UDF_Binary.Reducing {
  init()
}
@dynamicMemberLookup @propertyWrapper public struct SourceOfTruth<AppState> where AppState : Swift.Equatable, AppState : SwiftUI_UDF_Binary.AppReducer {
  public var wrappedValue: AppState
  public var projectedValue: SwiftUI_UDF_Binary.SourceOfTruth<AppState> {
    get
    set
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<AppState, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<AppState, R>) -> SwiftUI_UDF_Binary.ReducerScope<R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
}
public struct Effect : SwiftUI_UDF_Binary.Effectable {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
  public init<P, A, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapper: @escaping (P.Output) -> A) where P : Combine.Publisher, A : Swift.Equatable, A : SwiftUI_UDF_Binary.Actionable, Id : Swift.Hashable, P.Failure == Swift.Error
  public init<P, A, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapper: @escaping (P.Output) -> A) where P : Combine.Publisher, A : Swift.Equatable, Id : Swift.Hashable, P.Failure == Swift.Error
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Id : Swift.Hashable, P.Failure == Swift.Error, P.Output == [Item]
  public init<P, Item, Id, EqItem>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapItem: @escaping (Item) -> EqItem) where P : Combine.Publisher, Id : Swift.Hashable, EqItem : Swift.Equatable, P.Failure == Swift.Error, P.Output == [Item]
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Item == P.Output, Id : Swift.Hashable, P.Failure == Swift.Error
  public init(action: SwiftUI_UDF_Binary.AnyAction)
  public init<A>(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, _ future: @escaping () -> A) where A : Swift.Equatable, A : SwiftUI_UDF_Binary.Actionable
  public typealias Failure = Swift.Never
  public typealias Output = SwiftUI_UDF_Binary.AnyAction
}
extension SwiftUI.View {
  public func sheetContainer<Destination, State>(_ stateType: State.Type, isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) -> some SwiftUI.View where Destination : SwiftUI.View, State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer
  
  public func sheetContainer<Destination>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, @SwiftUI.ViewBuilder destination: @escaping () -> Destination) -> some SwiftUI.View where Destination : SwiftUI_UDF_Binary.Container
  
}
@available(*, deprecated, message: "Use `sheetContainer with destination as a closure`")
extension SwiftUI.View {
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: C, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping () -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping () -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
}
@dynamicMemberLookup public struct ReducerReference<AppState, Reducer> where AppState : Swift.Equatable, AppState : SwiftUI_UDF_Binary.AppReducer, Reducer : Swift.Equatable, Reducer : SwiftUI_UDF_Binary.Reducing {
  public var projectedValue: Reducer {
    get
    set
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<Reducer, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<Reducer, R>) -> SwiftUI_UDF_Binary.ReducerScope<R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
}
extension SwiftUI_UDF_Binary.ReducerReference where Reducer : SwiftUI_UDF_Binary.Formable {
  public subscript<T>(dynamicMember keyPath: Swift.WritableKeyPath<Reducer, T>) -> SwiftUI.Binding<T> where T : Swift.Equatable {
    get
  }
}
public struct ActionGroup : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
  public var actions: [SwiftUI_UDF_Binary.AnyAction]
  public init<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init<T>(actions: [T], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init(@SwiftUI_UDF_Binary.ActionGroupBuilder _ builder: () -> SwiftUI_UDF_Binary.ActionGroup)
  public init(anyActions: [SwiftUI_UDF_Binary.AnyAction])
  public init()
  public static func == (a: SwiftUI_UDF_Binary.ActionGroup, b: SwiftUI_UDF_Binary.ActionGroup) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.ActionGroup : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SwiftUI_UDF_Binary.ActionGroup {
  public mutating func append<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public mutating func append(action: SwiftUI_UDF_Binary.AnyAction)
  public mutating func append(actions: [SwiftUI_UDF_Binary.AnyAction])
}
extension SwiftUI_UDF_Binary.ActionGroup {
  public mutating func insert<T>(action: T, at: Swift.Int = 0, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public mutating func insert(action: SwiftUI_UDF_Binary.AnyAction, at: Swift.Int = 0)
}
@_Concurrency.MainActor(unsafe) public struct PlainNavigationLink<State, Label, Destination> : SwiftUI_UDF_Binary.NavigationContainerLinking where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Label : SwiftUI.View, Destination : SwiftUI.View {
  @_Concurrency.MainActor(unsafe) public var isDetailLink: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary19PlainNavigationLinkV4bodyQrvp", 0) __<State, Label, Destination>
}
extension Swift.Hashable {
  public static func == (lhs: Swift.AnyHashable, rhs: Self) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Swift.AnyHashable?, rhs: Self) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable?) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class EnvironmentStore<State> : SwiftUI_UDF_Binary.Store<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  override public init(initial state: State, accessToken: Swift.String, loggers: [SwiftUI_UDF_Binary.ActionLogging])
  convenience public init(initial state: State, accessToken: Swift.String, logger: SwiftUI_UDF_Binary.ActionLogging)
  override final public func subscribe(middleware: SwiftUI_UDF_Binary.Middleware<State>)
  override final public func dispatch(_ action: SwiftUI_UDF_Binary.AnyAction)
  @objc deinit
}
public enum ModalKind {
  case sheet
  case fullScreen
  public static func == (a: SwiftUI_UDF_Binary.ModalKind, b: SwiftUI_UDF_Binary.ModalKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class Store<State> : Foundation.ObservableObject where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  @SwiftUI_UDF_Binary.SourceOfTruth @_projectedValueProperty($state) public var state: State {
    get
    set
  }
  public var $state: SwiftUI_UDF_Binary.SourceOfTruth<State> {
    get
    set
  }
  public init(initial state: State, accessToken: Swift.String, loggers: [SwiftUI_UDF_Binary.ActionLogging])
  public func subscribe(_ middlewareType: SwiftUI_UDF_Binary.Middleware<State>.Type)
  public func subscribe(middleware: SwiftUI_UDF_Binary.Middleware<State>)
  public func dispatch<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func dispatch(_ action: SwiftUI_UDF_Binary.AnyAction)
  public func bind(_ action: SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.Command
  public func bind<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.Command where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func bind<T>(_ action: @escaping (T) -> SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.CommandWith<T>
  public func bind<Action, T>(_ action: @escaping (T) -> Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.CommandWith<T> where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
@_functionBuilder public enum ContainerBuilder {
  public static func buildBlock() -> SwiftUI_UDF_Binary.RenderContainer<SwiftUI.EmptyView, SwiftUI_UDF_Binary.EmptyReducer>
  public static func buildBlock<C>(_ container: C) -> C where C : SwiftUI_UDF_Binary.Container
  public static func buildEither<C>(first container: C) -> C where C : SwiftUI_UDF_Binary.Container
  public static func buildEither<C>(second container: C) -> C where C : SwiftUI_UDF_Binary.Container
  public static func buildExpression<V>(_ expression: V) -> SwiftUI_UDF_Binary.RenderContainer<V, SwiftUI_UDF_Binary.EmptyReducer> where V : SwiftUI.View
}
@_inheritsConvenienceInitializers open class ReducibleMiddleware<State> : SwiftUI_UDF_Binary.Middleware<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  required public init()
  required convenience public init(store: SwiftUI_UDF_Binary.Store<State>)
  override public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  open func reduce(_ action: SwiftUI_UDF_Binary.AnyAction, for state: State)
  @objc deinit
}
extension SwiftUI_UDF_Binary.Effects {
  public struct Filter<A> : SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Actionable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
    public init<E>(_ effect: E, _ isInclude: @escaping (A) -> Swift.Bool) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.AnyAction
  }
}
public enum Flows {
}
extension SwiftUI_UDF_Binary.Flows {
  public struct Id : Swift.Hashable, Swift.Codable {
    public init(value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SwiftUI_UDF_Binary.Flows.Id, b: SwiftUI_UDF_Binary.Flows.Id) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class XCTestStore<State> : SwiftUI_UDF_Binary.Store<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public init(initial state: State)
  override final public func subscribe(middleware: SwiftUI_UDF_Binary.Middleware<State>)
  override final public func dispatch(_ action: SwiftUI_UDF_Binary.AnyAction)
  @objc deinit
}
public struct FileCache {
  public var fileManager: Foundation.FileManager
  public var directoryName: Swift.String
  public var key: Swift.String
  public init(key: Swift.String)
  public init(key: Swift.String, fileManager: Foundation.FileManager = .default, directoryName: Swift.String = "StateData")
}
extension SwiftUI_UDF_Binary.FileCache : SwiftUI_UDF_Binary.CacheSource {
  public func save<T>(_ value: T) where T : Swift.Encodable
  public func load<T>() -> T? where T : Swift.Decodable
  public func remove()
}
extension SwiftUI.View {
  public func sheetContainer<State, Destination, I>(_ stateType: State.Type, item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, destination: @escaping (I) -> Destination) -> some SwiftUI.View where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Destination : SwiftUI.View, I : Swift.Identifiable
  
  public func sheetContainer<State, Destination, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, destination: @escaping (I) -> Destination) -> some SwiftUI.View where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer, Destination : SwiftUI_UDF_Binary.Container, I : Swift.Identifiable
  
}
@available(*, deprecated, message: "Use `sheetContainer with destination as a closure`")
extension SwiftUI.View {
  public func sheetContainer<C, V, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping (I) -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View, I : Swift.Identifiable
  
  public func sheetContainer<C, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping (I) -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, I : Swift.Identifiable
  
}
@_inheritsConvenienceInitializers open class ObservableMiddleware<State> : SwiftUI_UDF_Binary.Middleware<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  open func observe(state: State)
  open func scope(for state: SwiftUI_UDF_Binary.SourceOfTruth<State>) -> SwiftUI_UDF_Binary.Scope
  override public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  @objc deinit
}
public protocol Reducing : SwiftUI_UDF_Binary.Initable, SwiftUI_UDF_Binary.IsEquatable {
  mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
extension SwiftUI_UDF_Binary.Reducing {
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
public typealias Reducible = Swift.Equatable & SwiftUI_UDF_Binary.Reducing
@_hasMissingDesignatedInitializers final public class ReducerScope<R> : SwiftUI_UDF_Binary.EquatableScope where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
  public static func == (lhs: SwiftUI_UDF_Binary.ReducerScope<R>, rhs: SwiftUI_UDF_Binary.ReducerScope<R>) -> Swift.Bool
  @objc deinit
}
extension SwiftUI_UDF_Binary.Middleware.Status : Swift.Equatable {}
extension SwiftUI_UDF_Binary.Middleware.Status : Swift.Hashable {}
extension SwiftUI_UDF_Binary.ModalKind : Swift.Equatable {}
extension SwiftUI_UDF_Binary.ModalKind : Swift.Hashable {}
