// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftUI_UDF_Binary
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CoreLocation/*.CLAuthorizationStatus*/
import CoreLocation/*.CLLocation*/
import Foundation
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
public protocol EnvironmentMiddleware {
  associatedtype Environment
  associatedtype State : SwiftUI_UDF_Binary.AppReducer
  var environment: Self.Environment! { get set }
  init(store: some Store<State>, environment: Self.Environment)
  init(store: some Store<State>, environment: Self.Environment, queue: Dispatch.DispatchQueue)
  static func buildLiveEnvironment(for store: some Store<State>) -> Self.Environment
  static func buildTestEnvironment(for store: some Store<State>) -> Self.Environment
}
extension SwiftUI_UDF_Binary.EnvironmentMiddleware where Self.Environment == () {
  public static func buildLiveEnvironment(for store: some Store<State>) -> Self.Environment
  public static func buildTestEnvironment(for store: some Store<State>) -> Self.Environment
}
public protocol WrappedReducer : SwiftUI_UDF_Binary.Reducing {
  var reducer: SwiftUI_UDF_Binary.Reducing { get set }
}
extension SwiftUI_UDF_Binary.WrappedReducer {
  public mutating func reduce(_ action: some Action)
}
public protocol IdentifiableFlow : SwiftUI_UDF_Binary.Flow {
  associatedtype FlowId
  static var id: Self.FlowId { get }
}
extension SwiftUI_UDF_Binary.IdentifiableFlow where Self.FlowId == SwiftUI_UDF_Binary.Flows.Id {
  public static var id: SwiftUI_UDF_Binary.Flows.Id {
    get
  }
}
public protocol Component : SwiftUI.View {
  associatedtype Props
  var props: Self.Props { get }
  init(props: Self.Props)
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol PureEffect<Output> : Combine.Publisher {
  var upstream: Combine.AnyPublisher<Self.Output, Self.Failure> { get }
}
#else
public protocol PureEffect : Combine.Publisher {
  var upstream: Combine.AnyPublisher<Self.Output, Self.Failure> { get }
}
#endif
extension SwiftUI_UDF_Binary.PureEffect {
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.Action, failure: @escaping (Self.Failure) -> SwiftUI_UDF_Binary.Action) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never>
}
extension SwiftUI_UDF_Binary.PureEffect where Self.Failure == Swift.Never {
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.Action) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never>
}
extension Combine.AnyPublisher : SwiftUI_UDF_Binary.PureEffect where Output == SwiftUI_UDF_Binary.Action, Failure == Swift.Never {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never> {
    get
  }
}
public protocol ErasableToEffect {
  var asEffectable: Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never> { get }
}
public struct LoggingAction : Swift.CustomDebugStringConvertible {
  public let value: SwiftUI_UDF_Binary.Action
  public let fileName: Swift.String
  public let functionName: Swift.String
  public let lineNumber: Swift.Int
  public var debugDescription: Swift.String {
    get
  }
}
public protocol ActionLogger : Swift.Sendable {
  func log(_ action: SwiftUI_UDF_Binary.LoggingAction)
}
@propertyWrapper final public class Cached<T> : SwiftUI_UDF_Binary.Initable where T : Swift.Decodable, T : Swift.Encodable {
  final public var key: Swift.String
  final public var defaultValue: T
  final public var intervalToSync: Foundation.TimeInterval
  public init()
  public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 1, storage: SwiftUI_UDF_Binary.CacheSource)
  convenience public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 1)
  public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 1, storage: SwiftUI_UDF_Binary.CacheSource) where T : SwiftUI_UDF_Binary.Initable
  convenience public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 1) where T : SwiftUI_UDF_Binary.Initable
  final public var wrappedValue: T {
    get
    set
  }
  final public func reset()
  @objc deinit
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.IsEquatable where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.Reducing where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
}
extension SwiftUI_UDF_Binary.Cached : SwiftUI_UDF_Binary.WrappedReducer where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Reducing {
  final public var reducer: SwiftUI_UDF_Binary.Reducing {
    get
    set
  }
}
extension SwiftUI_UDF_Binary.Cached : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.Cached<T>, rhs: SwiftUI_UDF_Binary.Cached<T>) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.Cached : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct EmptyReducer : SwiftUI_UDF_Binary.AppReducer {
  public init()
  public mutating func reduce(_ action: some Action) -> Swift.Bool
  public static func == (a: SwiftUI_UDF_Binary.EmptyReducer, b: SwiftUI_UDF_Binary.EmptyReducer) -> Swift.Bool
}
public protocol Mergeable {
  func merging(_ newValue: Self) -> Self
  func filled(from value: Self, mutate: (_ filled: inout Self, _ old: Self) -> Swift.Void) -> Self
}
extension Swift.Dictionary where Value : SwiftUI_UDF_Binary.Mergeable {
  public subscript(key: Key) -> Value {
    get
    set
  }
}
extension Swift.Dictionary where Key == Value.ID, Value : Swift.Identifiable {
  public mutating func insert(items: [Value])
  public mutating func insert(item: Value)
}
public typealias MI = Swift.Identifiable & SwiftUI_UDF_Binary.Mergeable
extension Swift.Dictionary where Key == Value.ID, Value : Swift.Identifiable, Value : SwiftUI_UDF_Binary.Mergeable {
  public mutating func insert(items: [Value])
  public mutating func insert(item: Value)
}
public protocol AppReducer : Swift.Equatable, SwiftUI_UDF_Binary.Scope {
  mutating func preReduce(_ action: some Action)
  mutating func postReduce(_ action: some Action)
}
extension SwiftUI_UDF_Binary.AppReducer {
  public func preReduce(_ action: some Action)
  public func postReduce(_ action: some Action)
}
public protocol IsEquatable {
  func isEqual(_ rhs: SwiftUI_UDF_Binary.IsEquatable) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.IsEquatable where Self : Swift.Equatable {
  public func isEqual(_ rhs: SwiftUI_UDF_Binary.IsEquatable) -> Swift.Bool
}
public protocol Action : Swift.Equatable {
}
extension SwiftUI_UDF_Binary.Action {
  public func with(animation: SwiftUI.Animation?) -> some SwiftUI_UDF_Binary.Action
  
}
extension SwiftUI_UDF_Binary.Effects {
  public struct Delay : SwiftUI_UDF_Binary.Effectable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never>
    public init<E>(_ effect: E, _ duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.Action
  }
}
public protocol Scope : SwiftUI_UDF_Binary.IsEquatable {
}
public typealias EquatableScope = Swift.Equatable & SwiftUI_UDF_Binary.Scope
@_functionBuilder public enum ScopesBuilder {
  public static func buildExpression<S>(_ expression: S) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope where S : Swift.Equatable, S : SwiftUI_UDF_Binary.Scope
  
  public static func buildExpression<R>(_ expression: R) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing
  
  public static func buildExpression<R>(_ expression: R) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope where R : SwiftUI_UDF_Binary.AppReducer
  
  public static func buildPartialBlock<S>(first scope: S) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope where S : Swift.Equatable, S : SwiftUI_UDF_Binary.Scope
  
  public static func buildPartialBlock<S1, S2>(accumulated: S1, next: S2) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope where S1 : Swift.Equatable, S1 : SwiftUI_UDF_Binary.Scope, S2 : Swift.Equatable, S2 : SwiftUI_UDF_Binary.Scope
  
}
public func Scopes(@SwiftUI_UDF_Binary.ScopesBuilder _ builder: () -> some EquatableScope) -> some Swift.Equatable & SwiftUI_UDF_Binary.Scope

public struct RenderContainer<V, AppState> : SwiftUI_UDF_Binary.Container where V : SwiftUI.View, AppState : SwiftUI_UDF_Binary.AppReducer {
  public typealias ContainerComponent = SwiftUI_UDF_Binary.RenderComponent<V>
  public var viewToRender: V
  public init(viewToRender: V) where AppState == SwiftUI_UDF_Binary.EmptyReducer
  public init(_ state: AppState, viewToRender: V)
  public init(_ state: AppState, @SwiftUI.ViewBuilder viewToRender: () -> V)
  public func map(store: SwiftUI_UDF_Binary.EnvironmentStore<AppState>) -> SwiftUI_UDF_Binary.RenderContainer<V, AppState>.ContainerComponent.Props
  public func scope(for state: AppState) -> SwiftUI_UDF_Binary.Scope
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderContainerV4bodyQrvp", 0) __<V, AppState>
  public typealias ContainerState = AppState
}
public struct RenderComponent<V> : SwiftUI_UDF_Binary.Component where V : SwiftUI.View {
  public struct Props {
  }
  public var props: SwiftUI_UDF_Binary.RenderComponent<V>.Props
  public init(props: SwiftUI_UDF_Binary.RenderComponent<V>.Props)
  @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderComponentV4bodyQrvp", 0) __<V>
}
extension SwiftUI_UDF_Binary.Mergeable {
  public func filled(from value: Self, mutate: (_ filledValue: inout Self, _ oldValue: Self) -> Swift.Void) -> Self
}
public enum MiddlewareStatus {
  case active
  case suspend
  public static func == (a: SwiftUI_UDF_Binary.MiddlewareStatus, b: SwiftUI_UDF_Binary.MiddlewareStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Form : Swift.Equatable, SwiftUI_UDF_Binary.Reducing {
}
public enum Actions {
  public struct Error : SwiftUI_UDF_Binary.Action {
    public var error: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(error: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Error, b: SwiftUI_UDF_Binary.Actions.Error) -> Swift.Bool
  }
  public struct Message : SwiftUI_UDF_Binary.Action {
    public var message: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(message: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Message, b: SwiftUI_UDF_Binary.Actions.Message) -> Swift.Bool
  }
  public struct LoadPage : SwiftUI_UDF_Binary.Action {
    public var id: Swift.AnyHashable
    public var pageNumber: Swift.Int
    public init<Id>(pageNumber: Swift.Int = 1, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.LoadPage, b: SwiftUI_UDF_Binary.Actions.LoadPage) -> Swift.Bool
  }
  public struct SetPaginationItems<I> : SwiftUI_UDF_Binary.Action where I : Swift.Equatable {
    public var id: Swift.AnyHashable
    public var items: [I]
    public init<Id>(items: [I], id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>, b: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>) -> Swift.Bool
  }
  public struct DidCancelEffect : SwiftUI_UDF_Binary.Action {
    public var cancelation: Swift.AnyHashable
    public init<Id>(by cancelation: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidCancelEffect, b: SwiftUI_UDF_Binary.Actions.DidCancelEffect) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct UpdateFormField<F> : SwiftUI_UDF_Binary.Action where F : SwiftUI_UDF_Binary.Form {
    public static func == (lhs: SwiftUI_UDF_Binary.Actions.UpdateFormField<F>, rhs: SwiftUI_UDF_Binary.Actions.UpdateFormField<F>) -> Swift.Bool
    public var value: Swift.Equatable
    public var keyPath: Swift.PartialKeyPath<F>
    public init<V>(keyPath: Swift.WritableKeyPath<F, V>, value: V) where V : Swift.Equatable
  }
  public struct ResetForm<F> : SwiftUI_UDF_Binary.Action where F : SwiftUI_UDF_Binary.Form {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.ResetForm<F>, b: SwiftUI_UDF_Binary.Actions.ResetForm<F>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct DidLoadItem<M> : SwiftUI_UDF_Binary.Action where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>) -> Swift.Bool
  }
  public struct DidLoadItems<M> : SwiftUI_UDF_Binary.Action, Swift.CustomStringConvertible where M : Swift.Equatable {
    public var items: [M]
    public var id: Swift.AnyHashable
    public var shortDescription: Swift.Bool
    public init<Id>(items: [M], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>) -> Swift.Bool
  }
  public struct DidUpdateItem<M> : SwiftUI_UDF_Binary.Action where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>, b: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>) -> Swift.Bool
  }
  public struct DeleteItem<M> : SwiftUI_UDF_Binary.Action where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteItem<M>, b: SwiftUI_UDF_Binary.Actions.DeleteItem<M>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct DidLoadNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.Action where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedItems<ParentId, Nested> : SwiftUI_UDF_Binary.Action, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var items: [Nested]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public var parentId: ParentId
    public init(parentId: ParentId, items: [Nested], shortDescription: Swift.Bool = true)
    public init<Id>(parentId: ParentId, items: [Nested], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedByParents<ParentId, Nested> : SwiftUI_UDF_Binary.Action, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var dictionary: [ParentId : [Nested]]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public init(dictionary: [ParentId : [Nested]], shortDescription: Swift.Bool = true)
    public init<Id>(dictionary: [ParentId : [Nested]], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidUpdateNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.Action where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DeleteNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.Action where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>) -> Swift.Bool
  }
}
extension SwiftUI_UDF_Binary.Actions {
  public struct RequestLocationAccess : SwiftUI_UDF_Binary.Action {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.RequestLocationAccess, b: SwiftUI_UDF_Binary.Actions.RequestLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateLocationAccess : SwiftUI_UDF_Binary.Action {
    public var access: CoreLocation.CLAuthorizationStatus
    public init(access: CoreLocation.CLAuthorizationStatus)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess, b: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateUserLocation : SwiftUI_UDF_Binary.Action {
    public var location: CoreLocation.CLLocation
    public init(location: CoreLocation.CLLocation)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation, b: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation) -> Swift.Bool
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Routing<Route> : SwiftUI_UDF_Binary.Initable {
  associatedtype Route
  associatedtype Destination : SwiftUI.View
  func view(for route: Self.Route) -> Self.Destination
}
#else
public protocol Routing : SwiftUI_UDF_Binary.Initable {
  associatedtype Route
  associatedtype Destination : SwiftUI.View
  func view(for route: Self.Route) -> Self.Destination
}
#endif
final public class Router<R> where R : SwiftUI_UDF_Binary.Routing {
  final public var routing: R
  public init(routing: R)
  public init()
  public init<MockView>(routing: R, @SwiftUI.ViewBuilder mocked: @escaping (_ routing: R, _ route: R.Route) -> MockView) where MockView : SwiftUI.View
  final public func view(for route: R.Route) -> some SwiftUI.View
  
  @objc deinit
}
extension Combine.Publishers {
  public static func IsolatedState<State>(from store: some Store<State>) -> Combine.AnyPublisher<State, Swift.Never>
}
extension SwiftUI.Binding {
  public init(_ bind: @autoclosure @escaping () -> SwiftUI.Binding<Value>)
}
public protocol Initable {
  init()
}
extension Swift.Dictionary : SwiftUI_UDF_Binary.Initable {
}
extension Swift.Set : SwiftUI_UDF_Binary.Initable {
}
extension Swift.Array : SwiftUI_UDF_Binary.Initable {
}
public typealias Command = () -> ()
public typealias CommandWith<T> = (T) -> ()
public protocol CacheSource {
  init(key: Swift.String)
  func save<T>(_ value: T) where T : Swift.Encodable
  func load<T>() -> T? where T : Swift.Decodable
  func remove()
}
public enum Effects {
}
public protocol Effectable : SwiftUI_UDF_Binary.PureEffect where Self.Failure == Swift.Never, Self.Output == SwiftUI_UDF_Binary.Action {
}
extension SwiftUI_UDF_Binary.Effectable {
  public func filterAction<A>(_ isIncluded: @escaping (A) -> Swift.Bool) -> some SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Action
  
  public func delay(duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) -> some SwiftUI_UDF_Binary.Effectable
  
}
extension CoreLocation.CLAuthorizationStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Container<ContainerState> : SwiftUI.View {
  associatedtype ContainerState : SwiftUI_UDF_Binary.AppReducer
  associatedtype ContainerComponent : SwiftUI_UDF_Binary.Component
  func map(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>) -> Self.ContainerComponent.Props
  @SwiftUI_UDF_Binary.ScopesBuilder func scope(for state: Self.ContainerState) -> SwiftUI_UDF_Binary.Scope
  func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
#else
public protocol Container : SwiftUI.View {
  associatedtype ContainerState : SwiftUI_UDF_Binary.AppReducer
  associatedtype ContainerComponent : SwiftUI_UDF_Binary.Component
  func map(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>) -> Self.ContainerComponent.Props
  @SwiftUI_UDF_Binary.ScopesBuilder func scope(for state: Self.ContainerState) -> SwiftUI_UDF_Binary.Scope
  func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
#endif
extension SwiftUI_UDF_Binary.Container {
  public func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
extension SwiftUI_UDF_Binary.Container {
  public var body: some SwiftUI.View {
    get
  }
}
@_functionBuilder public enum ActionGroupBuilder {
  public static func buildArray(_ components: [[Swift.Equatable]], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> [Swift.Equatable]
  public static func buildBlock(_ components: [Swift.Equatable]..., fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> [Swift.Equatable]
  public static func buildExpression(_ expression: some Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> [Swift.Equatable]
  public static func buildExpression(_ expression: Swift.Void) -> [Swift.Equatable]
  public static func buildOptional(_ component: [Swift.Equatable]?) -> [Swift.Equatable]
  public static func buildEither(first component: [Swift.Equatable]) -> [Swift.Equatable]
  public static func buildEither(second component: [Swift.Equatable]) -> [Swift.Equatable]
  public static func buildLimitedAvailability(_ component: [Swift.Equatable]) -> [Swift.Equatable]
  public static func buildFinalResult(_ component: [Swift.Equatable], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.ActionGroup
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Middleware<State> {
  associatedtype State : SwiftUI_UDF_Binary.AppReducer
  var store: any SwiftUI_UDF_Binary.Store<Self.State> { get }
  var queue: Dispatch.DispatchQueue { get set }
  init(store: some Store<State>)
  init(store: some Store<State>, queue: Dispatch.DispatchQueue)
  func status(for state: Self.State) -> SwiftUI_UDF_Binary.MiddlewareStatus
  @discardableResult
  func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  func cancelAll()
}
#else
public protocol Middleware {
  associatedtype State : SwiftUI_UDF_Binary.AppReducer
  var store: any SwiftUI_UDF_Binary.Store<Self.State> { get }
  var queue: Dispatch.DispatchQueue { get set }
  init(store: some Store<State>)
  init(store: some Store<State>, queue: Dispatch.DispatchQueue)
  func status(for state: Self.State) -> SwiftUI_UDF_Binary.MiddlewareStatus
  @discardableResult
  func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  func cancelAll()
}
#endif
extension SwiftUI_UDF_Binary.Middleware {
  public init(store: some Store<State>)
}
extension SwiftUI_UDF_Binary.Middleware where Self : SwiftUI_UDF_Binary.EnvironmentMiddleware {
  public init(store: some Store<State>)
  public init(store: some Store<State>, queue: Dispatch.DispatchQueue)
  public init(store: some Store<State>, environment: Self.Environment)
  public init(store: some Store<State>, environment: Self.Environment, queue: Dispatch.DispatchQueue)
}
public protocol Flow : Swift.Equatable, SwiftUI_UDF_Binary.Reducing {
  init()
}
@_hasMissingDesignatedInitializers @propertyWrapper @dynamicMemberLookup final public class SourceOfTruth<AppState> where AppState : SwiftUI_UDF_Binary.AppReducer {
  final public var wrappedValue: AppState
  final public var projectedValue: SwiftUI_UDF_Binary.SourceOfTruth<AppState> {
    get
  }
  final public subscript<R>(dynamicMember keyPath: Swift.KeyPath<AppState, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  final public subscript<R>(dynamicMember keyPath: Swift.KeyPath<AppState, R>) -> SwiftUI_UDF_Binary.ReducerScope<R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  @objc deinit
}
extension SwiftUI_UDF_Binary.SourceOfTruth : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.SourceOfTruth<AppState>, rhs: SwiftUI_UDF_Binary.SourceOfTruth<AppState>) -> Swift.Bool
}
public struct Effect : SwiftUI_UDF_Binary.Effectable {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never>
  public init<P, A, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapper: @escaping (P.Output) -> A) where P : Combine.Publisher, A : SwiftUI_UDF_Binary.Action, Id : Swift.Hashable, P.Failure == Swift.Error
  public init<P, A, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapper: @escaping (P.Output) -> A) where P : Combine.Publisher, A : Swift.Equatable, Id : Swift.Hashable, P.Failure == Swift.Error
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Id : Swift.Hashable, P.Failure == Swift.Error, P.Output == [Item]
  public init<P, Item, Id, EqItem>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapItem: @escaping (Item) -> EqItem) where P : Combine.Publisher, Id : Swift.Hashable, EqItem : Swift.Equatable, P.Failure == Swift.Error, P.Output == [Item]
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Item == P.Output, Id : Swift.Hashable, P.Failure == Swift.Error
  public init(action: SwiftUI_UDF_Binary.Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public init(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, _ future: @escaping () -> SwiftUI_UDF_Binary.Action)
  public typealias Failure = Swift.Never
  public typealias Output = SwiftUI_UDF_Binary.Action
}
open class BaseMiddleware<State> : SwiftUI_UDF_Binary.Middleware where State : SwiftUI_UDF_Binary.AppReducer {
  public var store: any SwiftUI_UDF_Binary.Store<State>
  public var queue: Dispatch.DispatchQueue
  required public init(store: some Store<State>, queue: Dispatch.DispatchQueue)
  open func status(for state: State) -> SwiftUI_UDF_Binary.MiddlewareStatus
  public typealias DispatchFilter<Output> = (_ state: State, _ output: Output) -> Swift.Bool
  public var cancelations: [Swift.AnyHashable : Combine.AnyCancellable]
  open func execute<E, Id>(_ effect: E, cancelation: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.Action
  open func execute<E, Id>(_ effect: E, cancelation: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable
  open func run<E, Id>(_ effect: E, cancelation: Id, dispatchFilter: @escaping SwiftUI_UDF_Binary.BaseMiddleware<State>.DispatchFilter<SwiftUI_UDF_Binary.Action>, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.Action
  open func run<E, Id>(_ effect: E, cancelation: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.Action
  @discardableResult
  open func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  open func cancelAll()
  @discardableResult
  open func cancel() -> Swift.Bool
  open func execute<E>(_ effect: E, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.PureEffect, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.Action
  open func execute<E>(_ effect: E, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect
  @objc deinit
}
@_hasMissingDesignatedInitializers @dynamicMemberLookup final public class ReducerReference<AppState, Reducer> where AppState : SwiftUI_UDF_Binary.AppReducer, Reducer : Swift.Equatable, Reducer : SwiftUI_UDF_Binary.Reducing {
  final public var projectedValue: Reducer {
    get
    set
  }
  final public subscript<R>(dynamicMember keyPath: Swift.KeyPath<Reducer, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  final public subscript<R>(dynamicMember keyPath: Swift.KeyPath<Reducer, R>) -> SwiftUI_UDF_Binary.ReducerScope<R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
  @objc deinit
}
extension SwiftUI_UDF_Binary.ReducerReference where Reducer : SwiftUI_UDF_Binary.Form {
  final public subscript<T>(dynamicMember keyPath: Swift.WritableKeyPath<Reducer, T>) -> SwiftUI.Binding<T> where T : Swift.Equatable {
    get
  }
}
public struct ActionGroup : SwiftUI_UDF_Binary.Action {
  public var actions: [SwiftUI_UDF_Binary.Action] {
    get
  }
  public init(action: some Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public init(actions: [SwiftUI_UDF_Binary.Action], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public init(@SwiftUI_UDF_Binary.ActionGroupBuilder _ builder: () -> SwiftUI_UDF_Binary.ActionGroup)
  public init()
}
extension SwiftUI_UDF_Binary.ActionGroup : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SwiftUI_UDF_Binary.ActionGroup {
  public static func == (lhs: SwiftUI_UDF_Binary.ActionGroup, rhs: SwiftUI_UDF_Binary.ActionGroup) -> Swift.Bool
}
extension SwiftUI_UDF_Binary.ActionGroup {
  public mutating func append(action: some Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public mutating func append(actions: [SwiftUI_UDF_Binary.Action], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
}
extension SwiftUI_UDF_Binary.ActionGroup {
  public mutating func insert(action: some Action, at: Swift.Int = 0, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
}
public protocol InitialSetup : SwiftUI_UDF_Binary.Reducing {
  associatedtype AppState : SwiftUI_UDF_Binary.AppReducer
  mutating func initialSetup(with state: Self.AppState)
}
extension Swift.Hashable {
  public static func == (lhs: Swift.AnyHashable, rhs: Self) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Swift.AnyHashable?, rhs: Self) -> Swift.Bool
}
extension Swift.Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable?) -> Swift.Bool
}
final public class EnvironmentStore<State> where State : SwiftUI_UDF_Binary.AppReducer {
  @SwiftUI_UDF_Binary.SourceOfTruth @_projectedValueProperty($state) final public var state: State {
    get
    set
    _modify
  }
  final public var $state: SwiftUI_UDF_Binary.SourceOfTruth<State> {
    get
  }
  public init(initial state: State, accessToken: Swift.String, loggers: [SwiftUI_UDF_Binary.ActionLogger]) throws
  convenience public init(initial state: State, accessToken: Swift.String, logger: SwiftUI_UDF_Binary.ActionLogger) throws
  final public func dispatch(_ action: some Action, priority: SwiftUI_UDF_Binary.ActionPriority = .default, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  @objc deinit
}
extension SwiftUI_UDF_Binary.EnvironmentStore {
  #if compiler(>=5.3) && $AsyncAwait
  final public func subscribe(_ middlewareBuilder: (_ store: any SwiftUI_UDF_Binary.Store<State>) -> some Middleware<State>) async
  #endif
  final public func subscribeAsync(_ middlewareBuilder: @escaping (_ store: any SwiftUI_UDF_Binary.Store<State>) -> some Middleware<State>, onSubscribe: @escaping () -> Swift.Void = {})
  #if compiler(>=5.3) && $AsyncAwait
  final public func subscribe<M>(_ middlewareType: M.Type) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func subscribe<M>(_ middlewareType: M.Type, environment: M.Environment) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func subscribe<M>(_ middlewareType: M.Type, on queue: Dispatch.DispatchQueue) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  final public func subscribe<M>(_ middlewareType: M.Type, environment: M.Environment, on queue: Dispatch.DispatchQueue) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  final public func subscribeAsync<M>(_ middlewareType: M.Type, onSubscribe: @escaping () -> Swift.Void = {}) where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  final public func subscribeAsync<M>(_ middlewareType: M.Type, environment: M.Environment, onSubscribe: @escaping () -> Swift.Void = {}) where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  final public func subscribeAsync<M>(_ middlewareType: M.Type, on queue: Dispatch.DispatchQueue, onSubscribe: @escaping () -> Swift.Void = {}) where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  final public func subscribeAsync<M>(_ middlewareType: M.Type, environment: M.Environment, on queue: Dispatch.DispatchQueue, onSubscribe: @escaping () -> Swift.Void = {}) where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
}
public protocol ConcurrencyEffect {
  associatedtype Id : Swift.Hashable
  var id: Self.Id { get }
  #if compiler(>=5.3) && $AsyncAwait
  func task() async throws -> SwiftUI_UDF_Binary.Action
  #endif
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Store<State> : _Concurrency.Actor {
  associatedtype State : SwiftUI_UDF_Binary.AppReducer
  var state: Self.State { get }
  nonisolated func dispatch(_ action: some Action, priority: SwiftUI_UDF_Binary.ActionPriority, fileName: Swift.String, functionName: Swift.String, lineNumber: Swift.Int)
}
#else
public protocol Store : _Concurrency.Actor {
  associatedtype State : SwiftUI_UDF_Binary.AppReducer
  var state: Self.State { get }
  nonisolated func dispatch(_ action: some Action, priority: SwiftUI_UDF_Binary.ActionPriority, fileName: Swift.String, functionName: Swift.String, lineNumber: Swift.Int)
}
#endif
extension SwiftUI_UDF_Binary.Store {
  nonisolated public func dispatch(_ action: some Action, priority: SwiftUI_UDF_Binary.ActionPriority = .default, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public func bind(_ action: some Action, priority: SwiftUI_UDF_Binary.ActionPriority = .default, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.Command
  public func bind<T>(_ action: @escaping (T) -> some Action, priority: SwiftUI_UDF_Binary.ActionPriority = .default, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.CommandWith<T>
}
public enum ActionPriority {
  case `default`
  case userInteractive
  public static func == (a: SwiftUI_UDF_Binary.ActionPriority, b: SwiftUI_UDF_Binary.ActionPriority) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ReducibleMiddleware : SwiftUI_UDF_Binary.Middleware {
  func reduce(_ action: some Action, for state: Self.State)
}
public typealias BaseReducibleMiddleware<State> = SwiftUI_UDF_Binary.BaseMiddleware<State> & SwiftUI_UDF_Binary.ReducibleMiddleware & SwiftUI_UDF_Binary.EnvironmentMiddleware where State : SwiftUI_UDF_Binary.AppReducer
extension SwiftUI_UDF_Binary.Effects {
  public struct Filter<A> : SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Action {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.Action, Swift.Never>
    public init<E>(_ effect: E, _ isInclude: @escaping (A) -> Swift.Bool) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.Action
  }
}
public enum Flows {
}
extension SwiftUI_UDF_Binary.Flows {
  public struct Id : Swift.Hashable, Swift.Codable {
    public init(value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SwiftUI_UDF_Binary.Flows.Id, b: SwiftUI_UDF_Binary.Flows.Id) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
extension _Concurrency.Task where Success == Swift.Never, Failure == Swift.Never {
  #if compiler(>=5.3) && $AsyncAwait
  public static func sleep(seconds: Foundation.TimeInterval) async throws
  #endif
}
@_Concurrency.MainActor final public class XCTestStore<State> where State : SwiftUI_UDF_Binary.AppReducer {
  @SwiftUI_UDF_Binary.SourceOfTruth @_projectedValueProperty($state) @_Concurrency.MainActor final public var state: State {
    get
    set
    _modify
  }
  @_Concurrency.MainActor final public var $state: SwiftUI_UDF_Binary.SourceOfTruth<State> {
    get
  }
  @_Concurrency.MainActor public init(initial state: State) throws
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor final public func subscribe<M>(_ middlewareType: M.Type) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor final public func subscribe<M>(_ middlewareType: M.Type, environment: M.Environment) async where State == M.State, M : SwiftUI_UDF_Binary.EnvironmentMiddleware, M : SwiftUI_UDF_Binary.Middleware
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor final public func dispatch(_ action: some Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) async
  #endif
  @objc deinit
}
public struct FileCache {
  public var fileManager: Foundation.FileManager
  public var directoryName: Swift.String
  public var key: Swift.String
  public init(key: Swift.String)
  public init(key: Swift.String, fileManager: Foundation.FileManager = .default, directoryName: Swift.String = "StateData")
}
extension SwiftUI_UDF_Binary.FileCache : SwiftUI_UDF_Binary.CacheSource {
  public func save<T>(_ value: T) where T : Swift.Encodable
  public func load<T>() -> T? where T : Swift.Decodable
  public func remove()
}
public protocol ObservableMiddleware : SwiftUI_UDF_Binary.Middleware {
  @SwiftUI_UDF_Binary.ScopesBuilder func scope(for state: Self.State) -> SwiftUI_UDF_Binary.Scope
  func observe(state: Self.State)
}
public typealias BaseObservableMiddleware<State> = SwiftUI_UDF_Binary.BaseMiddleware<State> & SwiftUI_UDF_Binary.ObservableMiddleware & SwiftUI_UDF_Binary.EnvironmentMiddleware where State : SwiftUI_UDF_Binary.AppReducer
open class BaseConcurrencyMiddleware<State> : SwiftUI_UDF_Binary.Middleware where State : SwiftUI_UDF_Binary.AppReducer {
  public var store: any SwiftUI_UDF_Binary.Store<State>
  public var queue: Dispatch.DispatchQueue
  public var cancelations: [Swift.AnyHashable : _Concurrency.Task<Swift.Void, Swift.Never>]
  required public init(store: some Store<State>, queue: Dispatch.DispatchQueue)
  public func status(for state: State) -> SwiftUI_UDF_Binary.MiddlewareStatus
  #if compiler(>=5.3) && $AsyncAwait
  public func execute<TaskId>(id: TaskId, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, _ task: @escaping (TaskId) async throws -> SwiftUI_UDF_Binary.Action) where TaskId : Swift.Hashable
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func execute<TaskId>(id: TaskId, cancelation: some Hashable, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, _ task: @escaping (TaskId) async throws -> SwiftUI_UDF_Binary.Action) where TaskId : Swift.Hashable
  #endif
  public func execute(_ effect: some ConcurrencyEffect, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line)
  public func execute<Id>(_ effect: some ConcurrencyEffect, cancelation: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where Id : Swift.Hashable
  @discardableResult
  public func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  public func cancelAll()
  @objc deinit
}
public typealias BaseConcurrencyObservableMiddleware<State> = SwiftUI_UDF_Binary.BaseConcurrencyMiddleware<State> & SwiftUI_UDF_Binary.ObservableMiddleware & SwiftUI_UDF_Binary.EnvironmentMiddleware where State : SwiftUI_UDF_Binary.AppReducer
public typealias BaseConcurrencyReducibleMiddleware<State> = SwiftUI_UDF_Binary.BaseConcurrencyMiddleware<State> & SwiftUI_UDF_Binary.ReducibleMiddleware & SwiftUI_UDF_Binary.EnvironmentMiddleware where State : SwiftUI_UDF_Binary.AppReducer
public protocol Reducing : SwiftUI_UDF_Binary.Initable, SwiftUI_UDF_Binary.IsEquatable {
  mutating func reduce(_ action: some Action)
}
extension SwiftUI_UDF_Binary.Reducing {
  public mutating func reduce(_ action: some Action)
}
public typealias Reducible = Swift.Equatable & SwiftUI_UDF_Binary.Reducing
@_hasMissingDesignatedInitializers final public class ReducerScope<R> : SwiftUI_UDF_Binary.EquatableScope where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
  public static func == (lhs: SwiftUI_UDF_Binary.ReducerScope<R>, rhs: SwiftUI_UDF_Binary.ReducerScope<R>) -> Swift.Bool
  @objc deinit
}
extension SwiftUI_UDF_Binary.MiddlewareStatus : Swift.Equatable {}
extension SwiftUI_UDF_Binary.MiddlewareStatus : Swift.Hashable {}
extension SwiftUI_UDF_Binary.ActionPriority : Swift.Equatable {}
extension SwiftUI_UDF_Binary.ActionPriority : Swift.Hashable {}
extension SwiftUI_UDF_Binary.XCTestStore : Swift.Sendable {}
