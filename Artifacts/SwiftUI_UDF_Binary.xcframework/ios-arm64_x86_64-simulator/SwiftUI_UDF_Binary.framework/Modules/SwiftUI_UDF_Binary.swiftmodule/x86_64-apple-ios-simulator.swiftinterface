// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target x86_64-apple-ios14.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftUI_UDF_Binary
import Combine
import CoreLocation/*.CLAuthorizationStatus*/
import CoreLocation/*.CLLocation*/
import Foundation
import Swift
import SwiftUI
public enum AlertBuilder {
  public struct AlertStatus : Swift.Equatable {
    public static var dismissed: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus {
      get
    }
    public static func == (lhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus, rhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus) -> Swift.Bool
    public var id: Swift.Int
    public var status: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus.Status
    public enum Status : Swift.Equatable {
      case presented(SwiftUI_UDF_Binary.AlertBuilder.AlertStyle)
      case dismissed
      public static func == (lhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus.Status, rhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus.Status) -> Swift.Bool
    }
    public init(error: Swift.String?)
    public init(message: Swift.String?)
    public init(title: Swift.String, message: Swift.String?)
    public init()
    public init(style: SwiftUI_UDF_Binary.AlertBuilder.AlertStyle)
  }
  public struct AlertStyle : Swift.Equatable {
    public static func == (lhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStyle, rhs: SwiftUI_UDF_Binary.AlertBuilder.AlertStyle) -> Swift.Bool
    public var id: Swift.Int
    public init(validationError text: Swift.String)
    public init(failure text: Swift.String)
    public init(success text: Swift.String)
    public init(message text: Swift.String)
    public init(title: Swift.String, message: Swift.String)
    public init(title: Swift.String, text: Swift.String, primaryButton: SwiftUI.Alert.Button, secondaryButton: SwiftUI.Alert.Button)
    public init(title: Swift.String, text: Swift.String, dismissButton: SwiftUI.Alert.Button)
  }
  public static func buildAlert(for style: SwiftUI_UDF_Binary.AlertBuilder.AlertStyle) -> SwiftUI.Alert
}
extension AlertBuilder.AlertStatus : Swift.Identifiable {
  public typealias ID = Swift.Int
}
public struct AnyAction {
  public let value: SwiftUI_UDF_Binary.Actionable
  public init<T>(_ value: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
}
extension AnyAction : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.AnyAction, rhs: SwiftUI_UDF_Binary.AnyAction) -> Swift.Bool
}
extension AnyAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol IdentifiableFlow : SwiftUI_UDF_Binary.Flow {
  associatedtype FlowId
  static var id: Self.FlowId { get }
}
extension IdentifiableFlow where Self.FlowId == SwiftUI_UDF_Binary.Flows.Id {
  public static var id: SwiftUI_UDF_Binary.Flows.Id {
    get
  }
}
public protocol Component : SwiftUI.View {
  associatedtype Props
  var props: Self.Props { get }
  init(props: Self.Props)
}
public protocol PureEffect : Combine.Publisher {
  var upstream: Combine.AnyPublisher<Self.Output, Self.Failure> { get }
}
extension PureEffect {
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.AnyAction, failure: @escaping (Self.Failure) -> SwiftUI_UDF_Binary.AnyAction) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
}
extension PureEffect where Self.Failure == Swift.Never {
  public func eraseToEffectable(output: @escaping (Self.Output) -> SwiftUI_UDF_Binary.AnyAction) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
  public func eraseToEffectable<O>(output: @escaping (Self.Output) -> O) -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> where O : Swift.Equatable, O : SwiftUI_UDF_Binary.Actionable
}
extension AnyPublisher : SwiftUI_UDF_Binary.PureEffect where Output == SwiftUI_UDF_Binary.AnyAction, Failure == Swift.Never {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> {
    get
  }
}
public protocol ErasableToEffect {
  var asEffectable: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never> { get }
}
public protocol ActionLogging {
  func log(_ action: SwiftUI_UDF_Binary.AnyAction)
}
@propertyWrapper final public class Cached<T> where T : Swift.Decodable, T : Swift.Encodable {
  final public var key: Swift.String
  final public var defaultValue: T
  final public var intervalToSync: Foundation.TimeInterval
  public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 2, storage: SwiftUI_UDF_Binary.CacheSource)
  convenience public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 2)
  public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 2, storage: SwiftUI_UDF_Binary.CacheSource) where T : SwiftUI_UDF_Binary.Initable
  convenience public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 2) where T : SwiftUI_UDF_Binary.Initable
  final public var wrappedValue: T {
    get
    set
  }
  @objc deinit
}
extension Cached : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.Cached<T>, rhs: SwiftUI_UDF_Binary.Cached<T>) -> Swift.Bool
}
extension Cached : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct EmptyReducer : SwiftUI_UDF_Binary.AppReducer, Swift.Equatable {
  public init()
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction) -> Swift.Bool
  public static func == (a: SwiftUI_UDF_Binary.EmptyReducer, b: SwiftUI_UDF_Binary.EmptyReducer) -> Swift.Bool
}
extension View {
  public func alert(status: SwiftUI.Binding<SwiftUI_UDF_Binary.AlertBuilder.AlertStatus>) -> some SwiftUI.View
  
}
public protocol Mergeable {
  func merging(_ newValue: Self) -> Self
  func filled(from value: Self, mutate: (inout Self, Self) -> Swift.Void) -> Self
}
extension Dictionary where Value : SwiftUI_UDF_Binary.Mergeable {
  public subscript(key: Key) -> Value {
    get
    set
  }
}
@propertyWrapper public struct FormField<F, Value> : SwiftUI_UDF_Binary.Reducible where F : Swift.Equatable, F : SwiftUI_UDF_Binary.Formable, Value : Swift.Equatable {
  public init()
  public var wrappedValue: Value
  public init(wrappedValue value: Value, _ formType: F.Type)
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  public static func == (a: SwiftUI_UDF_Binary.FormField<F, Value>, b: SwiftUI_UDF_Binary.FormField<F, Value>) -> Swift.Bool
}
public protocol AppReducer {
  mutating func preReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  mutating func postReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
extension AppReducer {
  public func preReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  public func postReduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
@dynamicMemberLookup @propertyWrapper public struct SourceOfTruth<AppState> where AppState : Swift.Equatable, AppState : SwiftUI_UDF_Binary.AppReducer {
  public var wrappedValue: AppState
  public var projectedValue: SwiftUI_UDF_Binary.SourceOfTruth<AppState> {
    get
    set
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<AppState, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
}
public protocol Actionable {
}
extension Actionable where Self : Swift.Equatable {
  public func eraseToAnyAction(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.AnyAction
}
extension Effects {
  public struct Delay : SwiftUI_UDF_Binary.Effectable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
    public init<E>(_ effect: E, _ duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.AnyAction
  }
}
public struct RenderContainer<V> : SwiftUI_UDF_Binary.Container where V : SwiftUI.View {
  public typealias ContainerComponent = SwiftUI_UDF_Binary.RenderComponent<V>
  public var viewToRender: V
  public init(viewToRender: V)
  public func map(state: SwiftUI_UDF_Binary.EmptyReducer, store: SwiftUI_UDF_Binary.EnvironmentStore<SwiftUI_UDF_Binary.EmptyReducer>) -> SwiftUI_UDF_Binary.RenderContainer<V>.ContainerComponent.Props
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderContainerV4bodyQrvp", 0) ðŸ¦¸<V>
  public typealias ContainerState = SwiftUI_UDF_Binary.EmptyReducer
}
public struct RenderComponent<V> : SwiftUI_UDF_Binary.Component where V : SwiftUI.View {
  public struct Props {
  }
  public var props: SwiftUI_UDF_Binary.RenderComponent<V>.Props
  public init(props: SwiftUI_UDF_Binary.RenderComponent<V>.Props)
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderComponentV4bodyQrvp", 0) ðŸ¦¸<V>
}
extension Mergeable {
  public func filled(from value: Self, mutate: (inout Self, Self) -> Swift.Void) -> Self
}
public protocol Formable : SwiftUI_UDF_Binary.Reducing {
}
public typealias Form = SwiftUI_UDF_Binary.Formable & SwiftUI_UDF_Binary.Reducible
public enum Actions {
  public struct Error : SwiftUI_UDF_Binary.EquatableAction {
    public var error: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(error: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Error, b: SwiftUI_UDF_Binary.Actions.Error) -> Swift.Bool
  }
  @available(*, deprecated, message: "Use `UpdateAlertStatus` action instead of `Message`")
  public struct Message : SwiftUI_UDF_Binary.EquatableAction {
    public var message: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(message: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.Message, b: SwiftUI_UDF_Binary.Actions.Message) -> Swift.Bool
  }
  public struct LoadPage : SwiftUI_UDF_Binary.EquatableAction {
    public var id: Swift.AnyHashable
    public var pageNumber: Swift.Int
    public init<Id>(pageNumber: Swift.Int = 1, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.LoadPage, b: SwiftUI_UDF_Binary.Actions.LoadPage) -> Swift.Bool
  }
  public struct SetPaginationItems<I> : SwiftUI_UDF_Binary.EquatableAction where I : Swift.Equatable {
    public var id: Swift.AnyHashable
    public var items: [I]
    public init<Id>(items: [I], id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>, b: SwiftUI_UDF_Binary.Actions.SetPaginationItems<I>) -> Swift.Bool
  }
  public struct UpdateAlertStatus : SwiftUI_UDF_Binary.EquatableAction {
    public var status: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus
    public var id: Swift.AnyHashable
    public init<Id>(status: SwiftUI_UDF_Binary.AlertBuilder.AlertStatus, id: Id) where Id : Swift.Hashable
    public init<Id>(style: SwiftUI_UDF_Binary.AlertBuilder.AlertStyle, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.UpdateAlertStatus, b: SwiftUI_UDF_Binary.Actions.UpdateAlertStatus) -> Swift.Bool
  }
}
extension Actions {
  public struct UpdateFormField<F, V> : SwiftUI_UDF_Binary.EquatableAction where F : SwiftUI_UDF_Binary.Formable, V : Swift.Equatable {
    public var keyPath: Swift.WritableKeyPath<F, V>
    public var value: V
    public init(keyPath: Swift.WritableKeyPath<F, V>, value: V)
    public static func == (a: SwiftUI_UDF_Binary.Actions.UpdateFormField<F, V>, b: SwiftUI_UDF_Binary.Actions.UpdateFormField<F, V>) -> Swift.Bool
  }
  public struct ResetForm<F> : SwiftUI_UDF_Binary.EquatableAction where F : SwiftUI_UDF_Binary.Formable {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.ResetForm<F>, b: SwiftUI_UDF_Binary.Actions.ResetForm<F>) -> Swift.Bool
  }
}
extension Actions {
  public struct DidLoadItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItem<M>) -> Swift.Bool
  }
  public struct DidLoadItems<M> : SwiftUI_UDF_Binary.EquatableAction, Swift.CustomStringConvertible where M : Swift.Equatable {
    public var items: [M]
    public var id: Swift.AnyHashable
    public var shortDescription: Swift.Bool
    public init<Id>(items: [M], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>, b: SwiftUI_UDF_Binary.Actions.DidLoadItems<M>) -> Swift.Bool
  }
  public struct DidUpdateItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>, b: SwiftUI_UDF_Binary.Actions.DidUpdateItem<M>) -> Swift.Bool
  }
  public struct DeleteItem<M> : SwiftUI_UDF_Binary.EquatableAction where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteItem<M>, b: SwiftUI_UDF_Binary.Actions.DeleteItem<M>) -> Swift.Bool
  }
}
extension Actions {
  public struct DidLoadNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedItems<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var items: [Nested]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public var parentId: ParentId
    public init(parentId: ParentId, items: [Nested], shortDescription: Swift.Bool = true)
    public init<Id>(parentId: ParentId, items: [Nested], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedItems<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidLoadNestedByParents<ParentId, Nested> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable, Swift.CustomStringConvertible where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var dictionary: [ParentId : [Nested]]
    public var id: Swift.AnyHashable?
    public var shortDescription: Swift.Bool
    public init(dictionary: [ParentId : [Nested]], shortDescription: Swift.Bool = true)
    public init<Id>(dictionary: [ParentId : [Nested]], id: Id, shortDescription: Swift.Bool = true) where Id : Swift.Hashable
    public var description: Swift.String {
      get
    }
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidLoadNestedByParents<ParentId, Nested>) -> Swift.Bool
  }
  public struct DidUpdateNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DidUpdateNestedItem<ParentId, Nested>) -> Swift.Bool
  }
  public struct DeleteNestedItem<ParentId, Nested> : SwiftUI_UDF_Binary.EquatableAction where ParentId : Swift.Hashable, Nested : Swift.Equatable {
    public var item: Nested
    public var id: Swift.AnyHashable?
    public var parentId: ParentId
    public init(parentId: ParentId, item: Nested)
    public init<Id>(parentId: ParentId, item: Nested, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>, b: SwiftUI_UDF_Binary.Actions.DeleteNestedItem<ParentId, Nested>) -> Swift.Bool
  }
}
extension Actions {
  public struct RequestLocationAccess : SwiftUI_UDF_Binary.EquatableAction {
    public init()
    public static func == (a: SwiftUI_UDF_Binary.Actions.RequestLocationAccess, b: SwiftUI_UDF_Binary.Actions.RequestLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateLocationAccess : SwiftUI_UDF_Binary.EquatableAction {
    public var access: CoreLocation.CLAuthorizationStatus
    public init(access: CoreLocation.CLAuthorizationStatus)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess, b: SwiftUI_UDF_Binary.Actions.DidUpdateLocationAccess) -> Swift.Bool
  }
  public struct DidUpdateUserLocation : SwiftUI_UDF_Binary.EquatableAction {
    public var location: CoreLocation.CLLocation
    public init(location: CoreLocation.CLLocation)
    public static func == (a: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation, b: SwiftUI_UDF_Binary.Actions.DidUpdateUserLocation) -> Swift.Bool
  }
}
@_inheritsConvenienceInitializers open class AsyncMiddleware<State> : SwiftUI_UDF_Binary.Middleware<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public typealias DispatchFilter<Output> = (State, Output) -> Swift.Bool
  public var cancelations: [Swift.AnyHashable : Combine.AnyCancellable]
  public func execute<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func execute<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable
  public func run<E, Id, F>(_ effect: E, cancelation: Id, dispatchFilter: @escaping SwiftUI_UDF_Binary.AsyncMiddleware<State>.DispatchFilter<F>) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, F : Swift.Equatable, F : SwiftUI_UDF_Binary.Actionable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func run<E, Id>(_ effect: E, cancelation: Id) where E : SwiftUI_UDF_Binary.PureEffect, Id : Swift.Hashable, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  @discardableResult
  public func cancel<Id>(by cancelation: Id) -> Swift.Bool where Id : Swift.Hashable
  public func cancelAll()
  override public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  @objc deinit
}
public protocol Initable {
  init()
}
extension Dictionary : SwiftUI_UDF_Binary.Initable {
}
extension Set : SwiftUI_UDF_Binary.Initable {
}
extension Array : SwiftUI_UDF_Binary.Initable {
}
@_inheritsConvenienceInitializers open class SyncMiddleware<State> : SwiftUI_UDF_Binary.Middleware<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public var cancellable: Combine.AnyCancellable?
  override open func status(for state: State) -> SwiftUI_UDF_Binary.Observer<State>.Status
  public func execute<E>(_ effect: E) where E : SwiftUI_UDF_Binary.PureEffect, E.Failure == Swift.Never, E.Output == SwiftUI_UDF_Binary.AnyAction
  public func execute<E>(_ effect: E) where E : SwiftUI_UDF_Binary.ErasableToEffect, E : SwiftUI_UDF_Binary.PureEffect
  public func cancel()
  override public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  @objc deinit
}
public typealias EquatableAction = Swift.Equatable & SwiftUI_UDF_Binary.Actionable
public typealias Command = () -> ()
public typealias CommandWith<T> = (T) -> ()
final public class Observer<State> : Swift.Hashable {
  public static func == (lhs: SwiftUI_UDF_Binary.Observer<State>, rhs: SwiftUI_UDF_Binary.Observer<State>) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public enum Status {
    case active
    case postponed
    case suspended
    public static func == (a: SwiftUI_UDF_Binary.Observer<State>.Status, b: SwiftUI_UDF_Binary.Observer<State>.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let queue: Dispatch.DispatchQueue
  final public let observe: (State) -> Swift.Void
  public init(queue: Dispatch.DispatchQueue, observe: @escaping (State) -> Swift.Void)
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
public protocol Middlewareable : AnyObject {
  associatedtype State : Swift.Equatable, SwiftUI_UDF_Binary.AppReducer
  var store: SwiftUI_UDF_Binary.Store<Self.State> { get }
  var queue: Dispatch.DispatchQueue { get }
  var asObserver: SwiftUI_UDF_Binary.Observer<Self.State> { get }
  func status(for state: Self.State) -> SwiftUI_UDF_Binary.Observer<Self.State>.Status
  func observe(state: Self.State)
}
extension Middlewareable {
  public var asObserver: SwiftUI_UDF_Binary.Observer<Self.State> {
    get
  }
  public func status(for state: Self.State) -> SwiftUI_UDF_Binary.Observer<Self.State>.Status
}
public protocol CacheSource {
  init(key: Swift.String)
  func save<T>(_ value: T) where T : Swift.Encodable
  func load<T>() -> T? where T : Swift.Decodable
  func remove()
}
public enum Effects {
}
public protocol Effectable : SwiftUI_UDF_Binary.PureEffect where Self.Failure == Swift.Never, Self.Output == SwiftUI_UDF_Binary.AnyAction {
}
extension Effectable {
  public func combine<E>(_ effect: E) -> some SwiftUI_UDF_Binary.Effectable where E : SwiftUI_UDF_Binary.Effectable
  
  public func filterAction<A>(_ isIncluded: @escaping (A) -> Swift.Bool) -> some SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Actionable
  
  public func delay(duration: Foundation.TimeInterval, queue: Dispatch.DispatchQueue) -> some SwiftUI_UDF_Binary.Effectable
  
}
extension CLAuthorizationStatus : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Container : SwiftUI.View {
  associatedtype ContainerState : Swift.Equatable, SwiftUI_UDF_Binary.AppReducer
  associatedtype ContainerComponent : SwiftUI_UDF_Binary.Component
  func map(state: Self.ContainerState, store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>) -> Self.ContainerComponent.Props
  func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
extension Container {
  public func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
  public func onContainerDidLoad(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.ContainerState>)
}
extension Container {
  public var body: some SwiftUI.View {
    get
  }
}
@_functionBuilder public enum ActionGroupBuilder {
  public static func buildArray(_ components: [[SwiftUI_UDF_Binary.AnyAction]]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildBlock(_ components: [SwiftUI_UDF_Binary.AnyAction]...) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildExpression<T>(_ expression: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> [SwiftUI_UDF_Binary.AnyAction] where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public static func buildExpression(_ expression: SwiftUI_UDF_Binary.AnyAction) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildExpression(_ expression: Swift.Void) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildOptional(_ component: [SwiftUI_UDF_Binary.AnyAction]?) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildEither(first component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildEither(second component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildLimitedAvailability(_ component: [SwiftUI_UDF_Binary.AnyAction]) -> [SwiftUI_UDF_Binary.AnyAction]
  public static func buildFinalResult(_ component: [SwiftUI_UDF_Binary.AnyAction]) -> SwiftUI_UDF_Binary.ActionGroup
}
open class Middleware<State> : SwiftUI_UDF_Binary.Middlewareable where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public var store: SwiftUI_UDF_Binary.Store<State>
  public var queue: Dispatch.DispatchQueue
  public init(store: SwiftUI_UDF_Binary.Store<State>, queue: Dispatch.DispatchQueue)
  required convenience public init(store: SwiftUI_UDF_Binary.Store<State>)
  open func observe(state: State)
  open func status(for state: State) -> SwiftUI_UDF_Binary.Observer<State>.Status
  @objc deinit
}
public struct NavigationContainerLink<C, Label> : SwiftUI.View where C : SwiftUI_UDF_Binary.Container, Label : SwiftUI.View {
  public init(destination: C, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  public init(destination: C, isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  public init(destination: C, isActive: SwiftUI.Binding<Swift.Bool>) where Label == SwiftUI.EmptyView
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary23NavigationContainerLinkV4bodyQrvp", 0) ðŸ¦¸<C, Label>
}
extension Binding where Value : Swift.Equatable {
  @available(*, deprecated, message: "Use `store.$state.<formName>.<fieldName>` instead of `Binding(form:keyPath:store:)`")
  public init<F, S>(form: F, keyPath: Swift.WritableKeyPath<F, Value>, store: SwiftUI_UDF_Binary.EnvironmentStore<S>, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where F : Swift.Equatable, F : SwiftUI_UDF_Binary.Formable, S : Swift.Equatable, S : SwiftUI_UDF_Binary.AppReducer
}
public protocol Flow : Swift.Equatable, SwiftUI_UDF_Binary.Reducing {
  init()
}
public struct Effect : SwiftUI_UDF_Binary.Effectable {
  public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
  public init<P, A, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapper: @escaping (P.Output) -> A) where P : Combine.Publisher, A : Swift.Equatable, A : SwiftUI_UDF_Binary.Actionable, Id : Swift.Hashable, P.Failure == Swift.Error
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Id : Swift.Hashable, P.Failure == Swift.Error, P.Output == Swift.Array<Item>
  public init<P, Item, Id, EqItem>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, mapItem: @escaping (Item) -> EqItem) where P : Combine.Publisher, Id : Swift.Hashable, EqItem : Swift.Equatable, P.Failure == Swift.Error, P.Output == Swift.Array<Item>
  public init<P, Item, Id>(_ publisher: P, id: Id, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where P : Combine.Publisher, Item : Swift.Equatable, Item == P.Output, Id : Swift.Hashable, P.Failure == Swift.Error
  public init(action: SwiftUI_UDF_Binary.AnyAction)
  public init<A>(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, _ future: @escaping () -> A) where A : Swift.Equatable, A : SwiftUI_UDF_Binary.Actionable
  public typealias Failure = Swift.Never
  public typealias Output = SwiftUI_UDF_Binary.AnyAction
}
extension View {
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: C, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping () -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping () -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
}
@dynamicMemberLookup public struct ReducerReference<AppState, Reducer> where AppState : Swift.Equatable, AppState : SwiftUI_UDF_Binary.AppReducer, Reducer : Swift.Equatable, Reducer : SwiftUI_UDF_Binary.Reducing {
  public var projectedValue: Reducer {
    get
    set
  }
  public subscript<R>(dynamicMember keyPath: Swift.KeyPath<Reducer, R>) -> SwiftUI_UDF_Binary.ReducerReference<AppState, R> where R : Swift.Equatable, R : SwiftUI_UDF_Binary.Reducing {
    get
  }
}
extension ReducerReference where Reducer : SwiftUI_UDF_Binary.Formable {
  public subscript<T>(dynamicMember keyPath: Swift.WritableKeyPath<Reducer, T>) -> SwiftUI.Binding<T> where T : Swift.Equatable {
    get
  }
}
public struct ActionGroup : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
  public var actions: [SwiftUI_UDF_Binary.AnyAction]
  public init<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init<T>(actions: [T], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init(@SwiftUI_UDF_Binary.ActionGroupBuilder _ builder: () -> SwiftUI_UDF_Binary.ActionGroup)
  public init(anyActions: [SwiftUI_UDF_Binary.AnyAction])
  public init()
  public static func == (a: SwiftUI_UDF_Binary.ActionGroup, b: SwiftUI_UDF_Binary.ActionGroup) -> Swift.Bool
}
extension ActionGroup : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension ActionGroup {
  public mutating func append<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public mutating func append(action: SwiftUI_UDF_Binary.AnyAction)
}
extension ActionGroup {
  public mutating func insert<T>(action: T, at: Swift.Int = 0, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public mutating func insert(action: SwiftUI_UDF_Binary.AnyAction, at: Swift.Int = 0)
}
extension Hashable {
  public static func == (lhs: Swift.AnyHashable, rhs: Self) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Swift.AnyHashable?, rhs: Self) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable?) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class EnvironmentStore<State> : SwiftUI_UDF_Binary.Store<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  override public init(initial state: State, logger: SwiftUI_UDF_Binary.ActionLogging)
  final public func subscribe(_ middlewareType: SwiftUI_UDF_Binary.Middleware<State>.Type)
  override final public func subscribe(observer: SwiftUI_UDF_Binary.Observer<State>)
  @objc deinit
}
public enum ModalKind {
  case sheet
  case fullScreen
  public static func == (a: SwiftUI_UDF_Binary.ModalKind, b: SwiftUI_UDF_Binary.ModalKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Effects {
  public struct CombineEffect : SwiftUI_UDF_Binary.Effectable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
    public init<E1, E2>(_ effect1: E1, _ effect2: E2) where E1 : SwiftUI_UDF_Binary.Effectable, E2 : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.AnyAction
  }
}
public class Store<State> : Foundation.ObservableObject where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  @SwiftUI_UDF_Binary.SourceOfTruth @_projectedValueProperty($state) public var state: State {
    get
    set
  }
  public var $state: SwiftUI_UDF_Binary.SourceOfTruth<State> {
    get
    set
  }
  public init(initial state: State, logger: SwiftUI_UDF_Binary.ActionLogging)
  public func subscribe(observer: SwiftUI_UDF_Binary.Observer<State>)
  public func subscribe<M>(middleware: M) where State == M.State, M : SwiftUI_UDF_Binary.Middlewareable
  public func dispatch<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func bind(_ action: SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.Command
  public func bind<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.Command where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func bind<T>(_ action: @escaping (T) -> SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.CommandWith<T>
  public func bind<Action, T>(_ action: @escaping (T) -> Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.CommandWith<T> where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
extension Effects {
  public struct Filter<A> : SwiftUI_UDF_Binary.Effectable where A : SwiftUI_UDF_Binary.Actionable {
    public var upstream: Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Swift.Never>
    public init<E>(_ effect: E, _ isInclude: @escaping (A) -> Swift.Bool) where E : SwiftUI_UDF_Binary.Effectable
    public typealias Failure = Swift.Never
    public typealias Output = SwiftUI_UDF_Binary.AnyAction
  }
}
public enum Flows {
}
extension Flows {
  public struct Id : Swift.Hashable, Swift.Codable {
    public init(value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SwiftUI_UDF_Binary.Flows.Id, b: SwiftUI_UDF_Binary.Flows.Id) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class XCTestStore<State> : SwiftUI_UDF_Binary.Store<State> where State : Swift.Equatable, State : SwiftUI_UDF_Binary.AppReducer {
  public init(initial state: State)
  override final public func subscribe(observer: SwiftUI_UDF_Binary.Observer<State>)
  override public init(initial state: State, logger: SwiftUI_UDF_Binary.ActionLogging)
  @objc deinit
}
public struct FileCache {
  public var fileManager: Foundation.FileManager
  public var directoryName: Swift.String
  public var key: Swift.String
  public init(key: Swift.String)
  public init(key: Swift.String, fileManager: Foundation.FileManager = .default, directoryName: Swift.String = "StateData")
}
extension FileCache : SwiftUI_UDF_Binary.CacheSource {
  public func save<T>(_ value: T) where T : Swift.Encodable
  public func load<T>() -> T? where T : Swift.Decodable
  public func remove()
}
extension View {
  public func sheetContainer<C, V, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping (I) -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View, I : Swift.Identifiable
  
  public func sheetContainer<C, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, kind: SwiftUI_UDF_Binary.ModalKind = .sheet, container: @escaping (I) -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, I : Swift.Identifiable
  
}
public protocol Reducing : SwiftUI_UDF_Binary.Initable {
  mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
  func isEqual(_ rhs: SwiftUI_UDF_Binary.Reducing) -> Swift.Bool
}
extension Reducing where Self : Swift.Equatable {
  public func isEqual(_ rhs: SwiftUI_UDF_Binary.Reducing) -> Swift.Bool
}
public typealias Reducible = Swift.Equatable & SwiftUI_UDF_Binary.Reducing
extension SwiftUI_UDF_Binary.Observer.Status : Swift.Equatable {}
extension SwiftUI_UDF_Binary.Observer.Status : Swift.Hashable {}
extension SwiftUI_UDF_Binary.ModalKind : Swift.Equatable {}
extension SwiftUI_UDF_Binary.ModalKind : Swift.Hashable {}
