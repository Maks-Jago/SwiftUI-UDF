// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios14.5 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwiftUI_UDF_Binary
import Combine
import Foundation
import Swift
import SwiftUI
public protocol Actionable {
}
extension Actionable where Self : Swift.Equatable {
  public func eraseToAnyAction(fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.AnyAction
}
public struct AnyAction {
  public let value: SwiftUI_UDF_Binary.Actionable
  public init<T>(_ value: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
}
extension AnyAction : Swift.Equatable {
  public static func == (lhs: SwiftUI_UDF_Binary.AnyAction, rhs: SwiftUI_UDF_Binary.AnyAction) -> Swift.Bool
}
extension AnyAction : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol Reducible {
  mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
public struct RenderContainer<V> : SwiftUI_UDF_Binary.Container where V : SwiftUI.View {
  public typealias ContainerComponent = SwiftUI_UDF_Binary.RenderComponent<V>
  public var viewToRender: V
  public init(viewToRender: V)
  public func map(state: Swift.Void, store: SwiftUI_UDF_Binary.EnvironmentStore<Swift.Void>) -> SwiftUI_UDF_Binary.RenderContainer<V>.ContainerComponent.Props
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderContainerV4bodyQrvp", 0) ðŸ¦¸<V>
  public typealias State = Swift.Void
}
public struct RenderComponent<V> : SwiftUI_UDF_Binary.Component where V : SwiftUI.View {
  public struct Props {
  }
  public var props: SwiftUI_UDF_Binary.RenderComponent<V>.Props
  public init(props: SwiftUI_UDF_Binary.RenderComponent<V>.Props)
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary15RenderComponentV4bodyQrvp", 0) ðŸ¦¸<V>
}
public class Observer<State> : Swift.Hashable {
  public static func == (lhs: SwiftUI_UDF_Binary.Observer<State>, rhs: SwiftUI_UDF_Binary.Observer<State>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public enum Status {
    case active
    case postponed(Swift.Int)
    case dead
  }
  final public let queue: Dispatch.DispatchQueue
  final public let observe: (State) -> SwiftUI_UDF_Binary.Observer<State>.Status
  public init(queue: Dispatch.DispatchQueue, observe: @escaping (State) -> SwiftUI_UDF_Binary.Observer<State>.Status)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct ActionGroup : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
  public var actions: [SwiftUI_UDF_Binary.AnyAction]
  public init<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init<T>(actions: [T], fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public init<A1, A2>(_ a1: A1, _ a2: A2, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where A1 : Swift.Equatable, A1 : SwiftUI_UDF_Binary.Actionable, A2 : Swift.Equatable, A2 : SwiftUI_UDF_Binary.Actionable
  public init<A1, A2, A3>(_ a1: A1, _ a2: A2, _ a3: A3, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where A1 : Swift.Equatable, A1 : SwiftUI_UDF_Binary.Actionable, A2 : Swift.Equatable, A2 : SwiftUI_UDF_Binary.Actionable, A3 : Swift.Equatable, A3 : SwiftUI_UDF_Binary.Actionable
  public init<A1, A2, A3, A4>(_ a1: A1, _ a2: A2, _ a3: A3, _ a4: A4, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where A1 : Swift.Equatable, A1 : SwiftUI_UDF_Binary.Actionable, A2 : Swift.Equatable, A2 : SwiftUI_UDF_Binary.Actionable, A3 : Swift.Equatable, A3 : SwiftUI_UDF_Binary.Actionable, A4 : Swift.Equatable, A4 : SwiftUI_UDF_Binary.Actionable
  public init<A1, A2, A3, A4, A5>(_ a1: A1, _ a2: A2, _ a3: A3, _ a4: A4, _ a5: A5, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where A1 : Swift.Equatable, A1 : SwiftUI_UDF_Binary.Actionable, A2 : Swift.Equatable, A2 : SwiftUI_UDF_Binary.Actionable, A3 : Swift.Equatable, A3 : SwiftUI_UDF_Binary.Actionable, A4 : Swift.Equatable, A4 : SwiftUI_UDF_Binary.Actionable, A5 : Swift.Equatable, A5 : SwiftUI_UDF_Binary.Actionable
  public init(anyActions: [SwiftUI_UDF_Binary.AnyAction])
  public init()
  public static func == (a: SwiftUI_UDF_Binary.ActionGroup, b: SwiftUI_UDF_Binary.ActionGroup) -> Swift.Bool
}
extension ActionGroup {
  public mutating func append<T>(action: T, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where T : Swift.Equatable, T : SwiftUI_UDF_Binary.Actionable
  public mutating func append(action: SwiftUI_UDF_Binary.AnyAction)
}
public struct NavigationContainerLink<C, Label> : SwiftUI.View where C : SwiftUI_UDF_Binary.Container, Label : SwiftUI.View {
  public init(destination: C, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  public init(destination: C, isActive: SwiftUI.Binding<Swift.Bool>, @SwiftUI.ViewBuilder label: @escaping () -> Label)
  public init(destination: C, isActive: SwiftUI.Binding<Swift.Bool>) where Label == SwiftUI.EmptyView
  public var body: some SwiftUI.View {
    get
  }
  public typealias Body = @_opaqueReturnTypeOf("$s18SwiftUI_UDF_Binary23NavigationContainerLinkV4bodyQrvp", 0) ðŸ¦¸<C, Label>
}
public protocol Middleware {
  associatedtype State
  var store: SwiftUI_UDF_Binary.Store<Self.State> { get }
  var asObserver: SwiftUI_UDF_Binary.Observer<Self.State> { get }
  func observe(state: Self.State)
}
@propertyWrapper final public class Boxed<Value> {
  final public var wrappedValue: Value
  public init(wrappedValue: Value)
  @objc deinit
}
public enum Flows {
}
extension Flows {
  public struct Id : Swift.Hashable {
    public init(value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: SwiftUI_UDF_Binary.Flows.Id, b: SwiftUI_UDF_Binary.Flows.Id) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Hashable {
  public static func == (lhs: Swift.AnyHashable, rhs: Self) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Swift.AnyHashable?, rhs: Self) -> Swift.Bool
}
extension Hashable {
  public static func == (lhs: Self, rhs: Swift.AnyHashable?) -> Swift.Bool
}
public protocol Flow : SwiftUI_UDF_Binary.Reducible {
  init()
}
extension View {
  public func sheetContainer<C, V, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, container: @escaping (I) -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View, I : Swift.Identifiable
  
  public func sheetContainer<C, I>(item: SwiftUI.Binding<I?>, onDismiss: (() -> Swift.Void)? = nil, container: @escaping (I) -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, I : Swift.Identifiable
  
}
public protocol IdentifiableFlow : SwiftUI_UDF_Binary.Flow {
  associatedtype FlowId
  static var id: Self.FlowId { get }
}
extension IdentifiableFlow where Self.FlowId == SwiftUI_UDF_Binary.Flows.Id {
  public static var id: SwiftUI_UDF_Binary.Flows.Id {
    get
  }
}
public protocol Mergeable {
  mutating func merge(_ newValue: Self)
}
extension Dictionary where Value : SwiftUI_UDF_Binary.Mergeable {
  public subscript(key: Key) -> Value {
    get
    set
  }
}
public enum PaginationPage {
  case number(Swift.Int)
  case lastPage(Swift.Int)
  public var pageNumber: Swift.Int {
    get
  }
}
public protocol Effect {
  associatedtype Error : Swift.Error
  func upstream() -> Combine.AnyPublisher<SwiftUI_UDF_Binary.AnyAction, Self.Error>
}
public protocol CacheSource {
  init(key: Swift.String)
  func save<T>(_ value: T) where T : Swift.Encodable
  func load<T>() -> T? where T : Swift.Decodable
  func remove()
}
public protocol Container : SwiftUI.View {
  associatedtype State
  associatedtype ContainerComponent : SwiftUI_UDF_Binary.Component
  func map(state: Self.State, store: SwiftUI_UDF_Binary.EnvironmentStore<Self.State>) -> Self.ContainerComponent.Props
  func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.State>)
  func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.State>)
}
extension Container {
  public func onContainerAppear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.State>)
  public func onContainerDisappear(store: SwiftUI_UDF_Binary.EnvironmentStore<Self.State>)
}
extension Container {
  public var body: some SwiftUI.View {
    get
  }
}
public protocol Component : SwiftUI.View {
  associatedtype Props
  var props: Self.Props { get }
  init(props: Self.Props)
}
extension View {
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C, V>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: @escaping () -> C, transform: @escaping (C) -> V) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container, V : SwiftUI.View
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: @escaping () -> C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
  public func sheetContainer<C>(isPresented: SwiftUI.Binding<Swift.Bool>, onDismiss: (() -> Swift.Void)? = nil, container: C) -> some SwiftUI.View where C : SwiftUI_UDF_Binary.Container
  
}
public struct OrderedSet<E> : Swift.Equatable, Swift.Collection where E : Swift.Hashable {
  public typealias Element = E
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public init()
  public init(_ array: [SwiftUI_UDF_Binary.OrderedSet<E>.Element])
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var contents: [SwiftUI_UDF_Binary.OrderedSet<E>.Element] {
    get
  }
  public func contains(_ member: SwiftUI_UDF_Binary.OrderedSet<E>.Element) -> Swift.Bool
  @discardableResult
  public mutating func append(_ newElement: SwiftUI_UDF_Binary.OrderedSet<E>.Element) -> Swift.Bool
  public mutating func append(_ array: [SwiftUI_UDF_Binary.OrderedSet<E>.Element])
  public mutating func removeFirst() -> SwiftUI_UDF_Binary.OrderedSet<E>.Element
  public mutating func removeLast() -> SwiftUI_UDF_Binary.OrderedSet<E>.Element
  public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool)
  public mutating func removeAll(where sholdBeRemoved: (SwiftUI_UDF_Binary.OrderedSet<E>.Element) -> Swift.Bool = { _ in true })
  public typealias Iterator = Swift.IndexingIterator<SwiftUI_UDF_Binary.OrderedSet<E>>
  public typealias SubSequence = Swift.Slice<SwiftUI_UDF_Binary.OrderedSet<E>>
}
extension OrderedSet : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: SwiftUI_UDF_Binary.OrderedSet<E>.Element...)
  public typealias ArrayLiteralElement = SwiftUI_UDF_Binary.OrderedSet<E>.Element
}
extension OrderedSet : Swift.RandomAccessCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> SwiftUI_UDF_Binary.OrderedSet<E>.Element {
    get
  }
}
public func == <T>(lhs: SwiftUI_UDF_Binary.OrderedSet<T>, rhs: SwiftUI_UDF_Binary.OrderedSet<T>) -> Swift.Bool where T : Swift.Hashable
extension OrderedSet : Swift.Hashable {
  @discardableResult
  public mutating func remove(_ element: SwiftUI_UDF_Binary.OrderedSet<E>.Element) -> SwiftUI_UDF_Binary.OrderedSet<E>.Element?
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Dictionary {
  public mutating func append<V>(value: V, by key: Key) where Value == SwiftUI_UDF_Binary.OrderedSet<V>, V : Swift.Hashable
}
extension OrderedSet : Swift.Codable where E : Swift.Decodable, E : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol Initable {
  init()
}
extension Dictionary : SwiftUI_UDF_Binary.Initable {
}
extension Set : SwiftUI_UDF_Binary.Initable {
}
extension Array : SwiftUI_UDF_Binary.Initable {
}
extension OrderedSet : SwiftUI_UDF_Binary.Initable {
}
@propertyWrapper final public class Cached<T> where T : Swift.Decodable, T : Swift.Encodable {
  final public var key: Swift.String
  final public var defaultValue: T
  final public var intervalToSync: Foundation.TimeInterval
  public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 2, storage: SwiftUI_UDF_Binary.CacheSource)
  convenience public init(key: Swift.String, defaultValue: T, intervalToSync: Foundation.TimeInterval = 2)
  public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 2, storage: SwiftUI_UDF_Binary.CacheSource) where T : SwiftUI_UDF_Binary.Initable
  convenience public init(key: Swift.String, defaultValue: T = .init(), intervalToSync: Foundation.TimeInterval = 2) where T : SwiftUI_UDF_Binary.Initable
  final public var wrappedValue: T {
    get
    set
  }
  @objc deinit
}
public struct FileCache {
  public var fileManager: Foundation.FileManager
  public var directoryName: Swift.String
  public var key: Swift.String
  public init(key: Swift.String)
  public init(key: Swift.String, fileManager: Foundation.FileManager = .default, directoryName: Swift.String = "StateData")
}
extension FileCache : SwiftUI_UDF_Binary.CacheSource {
  public func save<T>(_ value: T) where T : Swift.Encodable
  public func load<T>() -> T? where T : Swift.Decodable
  public func remove()
}
final public class Store<State> {
  public typealias Reducer = (inout State, SwiftUI_UDF_Binary.AnyAction) -> ()
  public init(initial state: State, reducer: @escaping SwiftUI_UDF_Binary.Store<State>.Reducer)
  final public let reducer: SwiftUI_UDF_Binary.Store<State>.Reducer
  final public var state: State {
    get
  }
  final public func dispatch<Action>(action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  final public func dispatch(action: SwiftUI_UDF_Binary.AnyAction)
  final public func subscribe(observer: SwiftUI_UDF_Binary.Observer<State>)
  @objc deinit
}
extension AnyAction {
  public struct Error : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
    public var error: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(error: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.Error, b: SwiftUI_UDF_Binary.AnyAction.Error) -> Swift.Bool
  }
  public struct Message : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
    public var message: Swift.String?
    public var id: Swift.AnyHashable
    public init<Id>(message: Swift.String? = nil, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.Message, b: SwiftUI_UDF_Binary.AnyAction.Message) -> Swift.Bool
  }
  public struct DidLoadItem<M> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.DidLoadItem<M>, b: SwiftUI_UDF_Binary.AnyAction.DidLoadItem<M>) -> Swift.Bool
  }
  public struct DidLoadItems<M> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable where M : Swift.Equatable {
    public var items: [M]
    public var id: Swift.AnyHashable
    public init<Id>(items: [M], id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.DidLoadItems<M>, b: SwiftUI_UDF_Binary.AnyAction.DidLoadItems<M>) -> Swift.Bool
  }
  public struct DidUpdateItem<M> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.DidUpdateItem<M>, b: SwiftUI_UDF_Binary.AnyAction.DidUpdateItem<M>) -> Swift.Bool
  }
  public struct DeleteItem<M> : SwiftUI_UDF_Binary.Actionable, Swift.Equatable where M : Swift.Equatable {
    public var item: M
    public var id: Swift.AnyHashable?
    public init(item: M)
    public init<Id>(item: M, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.DeleteItem<M>, b: SwiftUI_UDF_Binary.AnyAction.DeleteItem<M>) -> Swift.Bool
  }
  public struct LoadPage : SwiftUI_UDF_Binary.Actionable, Swift.Equatable {
    public var id: Swift.AnyHashable
    public var pageNumber: Swift.Int
    public init<Id>(pageNumber: Swift.Int = 1, id: Id) where Id : Swift.Hashable
    public static func == (a: SwiftUI_UDF_Binary.AnyAction.LoadPage, b: SwiftUI_UDF_Binary.AnyAction.LoadPage) -> Swift.Bool
  }
}
public struct Paginator<StorageItem, LoadItem, Flow> : SwiftUI_UDF_Binary.Reducible where StorageItem : Swift.Hashable, LoadItem : Swift.Equatable, Flow : SwiftUI_UDF_Binary.IdentifiableFlow, Flow.FlowId : Swift.Hashable {
  public var items: SwiftUI_UDF_Binary.OrderedSet<StorageItem>
  public var page: SwiftUI_UDF_Binary.PaginationPage
  public var perPage: Swift.Int
  public var usePrefixForFirstPage: Swift.Bool
  public var mapper: (LoadItem) -> StorageItem
  public init(perPage: Swift.Int, usePrefixForFirstPage: Swift.Bool = true, mapper: @escaping (LoadItem) -> StorageItem)
  public init(perPage: Swift.Int, usePrefixForFirstPage: Swift.Bool = true, idPath: Swift.KeyPath<LoadItem, StorageItem>)
  public mutating func reduce(_ action: SwiftUI_UDF_Binary.AnyAction)
}
public typealias Command = () -> ()
public typealias CommandWith<T> = (T) -> ()
public class EnvironmentStore<State> : Foundation.ObservableObject {
  final public let store: SwiftUI_UDF_Binary.Store<State>
  @Combine.Published @_projectedValueProperty($state) public var state: State {
    get
  }
  public var $state: Combine.Published<State>.Publisher {
    get
  }
  public init(store: SwiftUI_UDF_Binary.Store<State>)
  public func dispatch<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func dispatch(_ action: SwiftUI_UDF_Binary.AnyAction)
  public func bind(_ action: SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.Command
  public func bind<Action>(_ action: Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.Command where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public func bind<T>(_ action: @escaping (T) -> SwiftUI_UDF_Binary.AnyAction) -> SwiftUI_UDF_Binary.CommandWith<T>
  public func bind<Action, T>(_ action: @escaping (T) -> Action, fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line) -> SwiftUI_UDF_Binary.CommandWith<T> where Action : Swift.Equatable, Action : SwiftUI_UDF_Binary.Actionable
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
